L 1 "..\src\xlink_Application.c"
N#include <hsf.h>
L 1 "..\sdk\1.50\include\hsf.h" 1
N
N/* hsf.h
N *
N * Copyright (C) 2013 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef _HSF_H_H_H_H_H_
N#define _HSF_H_H_H_H_H_
N
N#include "hfconfig.h"
L 1 "..\sdk\1.50\include\hfconfig.h" 1
N
N
N/* hfconfig.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N#ifndef _HF_CONFIG_H_H_H_
N#define _HF_CONFIG_H_H_H_
N
N#define __USE_HSF_API__
N
N#ifdef _ATMEL_ASF_
S#define CONFIG_HAVE_MALLINFO		1
S#define CONFIG_HAVE_TIME_FUNCS	1
S#define CONFIG_HAVE_SETTIMEOFDAY 	0
S#define CONFIG_HAVE_GETTIMEOFDAY 	1
S//#define CONFIG_NO_STRUCT_TIMEZONE
S#define CONFIG_CHIP_SAM4SXX
S#define CONFIG_CHIP_SAM4S16B
S//#define CONFIG_CHIP_SAM4SA168
S//#define CONFIG_CHIP_SAM4S8B
S#define CONFIG_MODULE_LPB
S#define CONFIG_FREERTOS
N#endif
N
N
N#ifdef __KEIL_MDK__
N#define CONFIG_HAVE_MALLINFO		0
N#define CONFIG_HAVE_TIME_FUNCS	1
N#define CONFIG_HAVE_SETTIMEOFDAY 	0
N#define CONFIG_HAVE_GETTIMEOFDAY 	0
N#define CONFIG_NO_STRUCT_TIMEZONE
N#define CONFIG_CHIP_HFO18
N#define CONFIG_MODULE_LPB100
N#define CONFIG_FREERTOS
N//#define CONFIG_USE_018_SDK_MSGQ
N#endif
N
N
N
N#endif
N
L 14 "..\sdk\1.50\include\hsf.h" 2
N
N#ifdef _ATMEL_ASF_
S#include <asf.h>
N#endif
N
N#if defined   ( __CC_ARM   )
X#if 1L
N#	define USER_FUNC	//__attribute__ ((section(".appmain")))
N#	define HSF_API		//__attribute__ ((section(".appmain")))
N#elif defined (  __GNUC__  )
S#   define USER_FUNC __attribute__((section(".appmain")))
S#	define HSF_API		__attribute__ ((section(".appmain")))
S#else
S#define USER_FUNC
N#endif
N
N#define HSF_IAPI		HSF_API
N
N#define _HSF_INLINE_	inline
N
N#ifndef bzero
N#define bzero(_ptr,_size)	memset(_ptr,0,_size)
N#endif
N
N#ifdef __BUILD_HSF_SDK__
S
S#ifdef CONFIG_CHIP_HFO18
S#include <os/os.h>
S#include "driver/gpio.h"
S#endif
S
S#ifdef CONFIG_FREERTOS
S#include <FreeRTOS.h>
S
S	#ifndef NORMAL_FREERTOS
S#define pvPortMalloc(size) OSMalloc(size, MMM_ALLOC_NORMAL)
S#define vPortFree(ptr) OSFree(ptr)
S	#endif
S	
S#endif
S
N#endif
N
N#include "hftypes.h"
L 1 "..\sdk\1.50\include\hftypes.h" 1
N
N#ifndef _HF_TYPES_H_H_
N#define _HF_TYPES_H_H_
N
N
N
N#ifdef __KEIL_MDK__
N	#ifdef __BUILD_HSF_SDK__
S#include <common/type.h>
N	#else
N#define false           (0)
N#define true            (1)
N#define	FALSE			(0)
N#define	TRUE			(1)
N
Ntypedef unsigned char   BOOL;
Ntypedef unsigned char   bool;
Ntypedef	unsigned int	size_t;
N	#endif
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 21 "..\sdk\1.50\include\hftypes.h" 2
N
N#endif
N
N#endif
N
L 57 "..\sdk\1.50\include\hsf.h" 2
N#include "hfsys.h"
L 1 "..\sdk\1.50\include\hfsys.h" 1
N
N/* hfsys.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N
N#ifndef _H_H_HFSYS_H_
N#define _H_H_HFSYS_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Nenum HFSYS_RUN_MODE_E
N{
N	HFSYS_STATE_RUN_THROUGH=0,
N	HFSYS_STATE_RUN_CMD=1,
N	HFSYS_STATE_RUN_GPIO,
N	HFSYS_STATE_RUN_PWM,
N	HFSYS_STATE_MAX_VALUE
N};
N
Nenum HFSYS_EVENT_E
N{
N	HFE_WIFI_STA_CONNECTED=0,
N	HFE_WIFI_STA_DISCONNECTED=1,
N	HFE_CONFIG_RELOAD,
N	HFE_DHCP_OK,
N	HFE_SMTLK_OK,
N};
N
N#define HFSYS_RESET_REASON_NORMAL			(0)
N#define HFSYS_RESET_REASON_ERESET			(0x00000001)
N#define HFSYS_RESET_REASON_IRESET0			(0x00000002)
N#define HFSYS_RESET_REASON_IRESET1			(0x00000004)
N#define HFSYS_RESET_REASON_WPS				(0x00000008)
N#define HFSYS_RESET_REASON_SMARTLINK_START	(0x00000010)
N#define HFSYS_RESET_REASON_SMARTLINK_OK		(0x00000020)
N#define HFSYS_RESET_REASON_WPS_OK			(0x00000080)
N
N	
N
Ntypedef int (*hfsys_event_callback_t)( uint32_t /*event_id*/,void * /*param*/);
N
N
Nuint32_t HSF_API  hfsys_get_reset_reason(void);
Xuint32_t   hfsys_get_reset_reason(void);
N
N
Nconst char * HSF_API hfsys_get_sdk_version(void);
Xconst char *  hfsys_get_sdk_version(void);
N
N//memory
N/*
N *
N*/
Nvoid * HSF_API hfmem_malloc(size_t size);
Xvoid *  hfmem_malloc(size_t size);
N
N/*
N *
N*/
Nvoid * HSF_API hfmem_realloc(void *pv, size_t size);
Xvoid *  hfmem_realloc(void *pv, size_t size);
N
N/*
N * 
N */
Nvoid HSF_API hfmem_free(void *pv);
Xvoid  hfmem_free(void *pv);
N
N
Nvoid HSF_API *hfmem_realloc(void *pv,size_t size);
Xvoid  *hfmem_realloc(void *pv,size_t size);
N
N
N/*
N *mode:参考HFSYS_RUN_MODE_E
N*/
Nint HSF_API hfsys_switch_run_mode(int mode);
Xint  hfsys_switch_run_mode(int mode);
N
N/*
N*/
Nint HSF_API hfsys_get_run_mode(void);
Xint  hfsys_get_run_mode(void);
N
N/*
N * reset hf module
N*/
Nvoid HSF_API hfsys_reset(void);
Xvoid  hfsys_reset(void);
N
Nvoid HSF_API hfsys_softreset(void);
Xvoid  hfsys_softreset(void);
N
N
N/*
N * reload config
N */
Nvoid HSF_API hfsys_reload(void);
Xvoid  hfsys_reload(void);
N
N/*
N * Retrieves the number of milliseconds that have elapsed since the system was started;
N */
Nuint32_t HSF_API hfsys_get_time(void);
Xuint32_t  hfsys_get_time(void);
N
N/*
N * Monitor memory status.
N */
Nuint32_t HSF_API hfsys_get_memory(void);
Xuint32_t  hfsys_get_memory(void);
N/*
N  *
N  */
Nint HSF_IAPI hfsys_send_event(uint32_t event_id,void *param);
Xint  hfsys_send_event(uint32_t event_id,void *param);
N
N/*
N *
N */
Nint HSF_API hfsys_register_system_event(hfsys_event_callback_t p_callback);
Xint  hfsys_register_system_event(hfsys_event_callback_t p_callback);
N
N/*
N
N*/
Nint HSF_API hfsys_unregister_system_event(void);
Xint  hfsys_unregister_system_event(void);
N
Nvoid HSF_API hfsys_disable_all_soft_watchdogs(void);
Xvoid  hfsys_disable_all_soft_watchdogs(void);
N
Nvoid HSF_API hfsys_enable_all_soft_watchdogs(void);
Xvoid  hfsys_enable_all_soft_watchdogs(void);
N
Nint HSF_API hfsys_nvm_read(uint32_t nvm_addr, char* buf, uint32_t length);
Xint  hfsys_nvm_read(uint32_t nvm_addr, char* buf, uint32_t length);
N
Nint HSF_API hfsys_nvm_write(uint32_t nvm_addr, char* buf, uint32_t length);
Xint  hfsys_nvm_write(uint32_t nvm_addr, char* buf, uint32_t length);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* HFSYS_H_ */
L 58 "..\sdk\1.50\include\hsf.h" 2
N#include "hferrno.h"
L 1 "..\sdk\1.50\include\hferrno.h" 1
N/* 
N *hferrno.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N
N#ifndef _HFERRNO_H_
N#define _HFERRNO_H_
N
N/* Get the module index number from error code (4th byte from LSB)*/
N#define get_module_base(code) ((code&0xFF0000)>>16)
N
N/* Get module notifier code (2nd and 1st byte from LSB)*/
N#define get_code(code) (code&0xFF)
N
N#define MOD_ERROR_START(x)  ((x << 16) | 0)
N
N/* Create Module index */
N#define MOD_GENERIC    0
N/** HTTPD module index */
N#define MOD_HTTPDE     1
N/** HTTP-CLIENT module index */
N#define MOD_HTTPC      2
N/** WPS module index */
N#define MOD_WPS        3
N/** WLAN module index */
N#define MOD_WLAN       4
N/** USB module index */
N#define MOD_USB        5
N
N#define MOD_USER_DEFINE		(0x80)
N
N/* Globally unique success code */
N#define HF_SUCCESS 0
N
Nenum hf_errno {
N	/* First Generic Error codes */
N	HF_GEN_E_BASE = MOD_ERROR_START(MOD_GENERIC),
X	HF_GEN_E_BASE = ((0 << 16) | 0),
N	HF_FAIL,
N	HF_E_PERM,   /* Operation not permitted */
N	HF_E_NOENT,  /* No such file or directory */
N	HF_E_SRCH,   /* No such process */
N	HF_E_INTR,   /* Interrupted system call */
N	HF_E_IO,     /* I/O error */
N	HF_E_NXIO,   /* No such device or address */
N	HF_E_2BIG,   /* Argument list too long */
N	HF_E_NOEXEC, /* Exec format error */
N	HF_E_BADF,   /* Bad file number */
N	HF_E_CHILD,  /* No child processes */
N	HF_E_AGAIN,  /* Try again */
N	HF_E_NOMEM,  /* Out of memory */
N	HF_E_ACCES,  /* Permission denied */
N	HF_E_FAULT,  /* Bad address */
N	HF_E_NOTBLK, /* Block device required */
N	HF_E_BUSY,   /* Device or resource busy */
N	HF_E_EXIST,  /* File exists */
N	HF_E_XDEV,   /* Cross-device link */
N	HF_E_NODEV,  /* No such device */
N	HF_E_NOTDIR, /* Not a directory */
N	HF_E_ISDIR,  /* Is a directory */
N	HF_E_INVAL,  /* Invalid argument */
N	HF_E_NFILE,  /* File table overflow */
N	HF_E_MFILE,  /* Too many open files */
N	HF_E_NOTTY,  /* Not a typewriter */
N	HF_E_TXTBSY, /* Text file busy */
N	HF_E_FBIG,   /* File too large */
N	HF_E_NOSPC,  /* No space left on device */
N	HF_E_SPIPE,  /* Illegal seek */
N	HF_E_ROFS,   /* Read-only file system */
N	HF_E_MLINK,  /* Too many links */
N	HF_E_PIPE,   /* Broken pipe */
N	HF_E_DOM,    /* Math argument out of domain of func */
N	HF_E_RANGE,  /* Math result not representable */
N	HF_E_DEADLK,    /*Resource deadlock would occur*/
N};
N
N
N#endif /* HFERRNO_H_ */
N
L 59 "..\sdk\1.50\include\hsf.h" 2
N#include "hf_debug.h"
L 1 "..\sdk\1.50\include\hf_debug.h" 1
N
N/* hf_debug.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N#ifndef HF_DEBUG
N#define HF_DEBUG
N
N//#include "status_codes.h"
N//extern status_code_t usart_serial_write_packet(usart_if usart, const uint8_t *data,size_t len);
N
N#define DEBUG_LWIP			DEBUG_LEVEL_CLOSE
N#define DEBUG_LWIP_ND		DEBUG_LEVEL_CLOSE
N#define DEBUG_WIFI			DEBUG_LEVEL_CLOSE
N#define DEBUG_WIFI_ND		DEBUG_LEVEL_CLOSE
N#define DEBUG_WIFI_TEST		DEBUG_LEVEL_CLOSE
N#define DEBUG_APP			DEBUG_LEVEL_CLOSE
N#define DEBUG_DHCPD			DEBUG_LEVEL_CLOSE
N#define DEBUG_HTTPD			DEBUG_LEVEL_MID
N#define DEBUG_HTTPD_ND		DEBUG_LEVEL_CLOSE
N#define DEBUG_TESTTH		DEBUG_LEVEL_CLOSE
N#define DEBUG_ASSIS			DEBUG_LEVEL_CLOSE
N#define DEBUG_PING			DEBUG_LEVEL_CLOSE
N#define DEBUG_WEB_LOGIN		DEBUG_LEVEL_CLOSE
N#define DEBUG_BOOTUP		DEBUG_LEVEL_CLOSE
N#define DEBUG_SECU			DEBUG_LEVEL_CLOSE
N#define DEBUG_DNS			DEBUG_LEVEL_CLOSE
N#define DEBUG_HTTPC			DEBUG_LEVEL_CLOSE
N#define DEBUG_SPI			DEBUG_LEVEL_CLOSE
N#define DEBUG_SOCKB			DEBUG_LEVEL_CLOSE
N#define DEBUG_WIFI_HEX		DEBUG_LEVEL_CLOSE
N#define DEBUG_APSTA			DEBUG_LEVEL_LOW
N#define DEBUG_CXMODE		DEBUG_LEVEL_CLOSE
N#define DEBUG_UPGRADE		DEBUG_LEVEL_MID
N#define DEBUG_WIFICOMPLETE	DEBUG_LEVEL_CLOSE	
N#define DEBUG_WPS				DEBUG_LEVEL_LOW
N#define DEBUG_SCAN				DEBUG_LEVEL_LOW
N#define DEBUG_SMTLK				6
N#define DEBUG_SMTLK_MID			5
N#define DEBUG_SMTLK_LOW			4
N#define DEBUG_TCPIP					10
N#define DEBUG_SSL				DEBUG_LEVEL_MID
N#define DEBUG_WEBSOCKETS	DEBUG_LEVEL_MID
N
N#define DEBUG_LEVEL_NON		-1
N#define DEBUG_LEVEL_CLOSE   	0
N#define DEBUG_LEVEL_LOW		1
N#define DEBUG_LEVEL_MID		2
N#define DEBUG_LEVEL_HI			3
N#define DEBUG_LEVEL_USER		10
N#define DEBUG_LEVEL			DEBUG_LEVEL_HI
N
N#define DEBUG_WARN			(DEBUG_LEVEL_USER-2)
N#define DEBUG_ERROR			(DEBUG_LEVEL_USER-2)
N
N//#define u_printf(net)
N#define __HF_DEBUG
N#ifdef __HF_DEBUG
Nvoid HF_Debug(int debug_level,const char *format , ... );
N#define hfdbg_error(...)	HF_Debug(DEBUG_ERROR,"[ %d error %s %d]",hfsys_get_time(),__FUNCTION__,__LINE__); \
N						HF_Debug(DEBUG_ERROR,__VA_ARGS__)
X#define hfdbg_error(...)	HF_Debug(DEBUG_ERROR,"[ %d error %s %d]",hfsys_get_time(),__FUNCTION__,__LINE__); 						HF_Debug(DEBUG_ERROR,__VA_ARGS__)
N#define hfdbg_warn(...)	HF_Debug(DEBUG_WARN,"[warnning %d %s %d]",hfsys_get_time(),__FUNCTION__,__LINE__); \
N						HF_Debug(DEBUG_WARN,__VA_ARGS__)
X#define hfdbg_warn(...)	HF_Debug(DEBUG_WARN,"[warnning %d %s %d]",hfsys_get_time(),__FUNCTION__,__LINE__); 						HF_Debug(DEBUG_WARN,__VA_ARGS__)
N						
Nvoid hfdbg_set_level(int level);
Nint hfdbg_get_level(void);
Nint hfdbg_check(void);
N#else
S#define hfdbg_set_level(level)
S#define hfdbg_get_level()	DEBUG_LEVEL_CLOSE
S#define HF_Debug(a, b , ... )
S#define hfdbg_check()	(0)
S#define hfdbg_error(...)
S#define hfdbg_warn(...)
S
N#endif
N
N#ifdef __BUILD_HSF_SDK__
S#define u_printf(...) HF_Debug(DEBUG_LEVEL,__VA_ARGS__)
N#else
N#define u_printf(...) HF_Debug(DEBUG_LEVEL_USER,__VA_ARGS__)
N#endif
N
N
N#endif
L 60 "..\sdk\1.50\include\hsf.h" 2
N#include "hfat.h"
L 1 "..\sdk\1.50\include\hfat.h" 1
N/* hfat.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N#ifndef _AT_H_H_H_
N#define _AT_H_H_H_
N
N#define HFAT_MAX_CMD_DATA_LEN	(255)
N
N#define HFAT_REPLY_FLAG_NOSEND_TAIL		(0x00000001)
N
Ntypedef int (*at_cmd_reply_func)(const char*,int len,int timeouts,int flags);
Ntypedef int (*at_cmd_read_func)(char*buf,int len,int timeouts,int flags);
N
Nenum session_id_e
N{
N	AT_SESSION_UART0=0,
N	AT_SESSION_UART1=1,
N	AT_SESSION_ASSIST_SOCKET,
N	AT_SESSION_API,
N};
N
Ntypedef struct _at_session
N{
N	at_cmd_reply_func pfreply;
N	at_cmd_read_func pfread;
N	int sid;
N	char *rsp;
N	int rsp_len;
N	int cmd_id;
N}at_session_t,*pat_session_t;
N
Ntypedef pat_session_t at_session_handle;
N
Ntypedef struct _at_cmd
N{
N	const char * name;
N	int	(*func)(pat_session_t,int, char** ,char *,int);	// the main func , or init
N	const char * doc;
N	int	(*callhook)(pat_session_t,int, char** ,char *,int);
N} hfat_cmd_t,*phfat_cmd_t;
N
Ntypedef struct _at_cmd_category
N{
N	const char *name;
N	phfat_cmd_t  item;
N}hfat_cmd_category,*phfat_cmd_category;
N/*
N *return value: <0 fail,>=0 success,the length of response
N*/
Nint HSF_API send_at_cmd(at_session_handle handle,char *cmd_line, int len,char *response,int rsplen);
Xint  send_at_cmd(at_session_handle handle,char *cmd_line, int len,char *response,int rsplen);
N
Nint HSF_API hfat_init(void);
Xint  hfat_init(void);
N
Nint HSF_API hfat_send_cmd(char *cmd_line,int cmd_len,char *rsp,int len);
Xint  hfat_send_cmd(char *cmd_line,int cmd_len,char *rsp,int len);
N
Nint HSF_API hfat_get_words(char *str,char **words,int size);
Xint  hfat_get_words(char *str,char **words,int size);
N
N#endif
N
N
L 61 "..\sdk\1.50\include\hsf.h" 2
N#include "hfgpio.h"
L 1 "..\sdk\1.50\include\hfgpio.h" 1
N
N/* hfgpio.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N#ifndef _HF_GPIO_H_H_H_
N#define _HF_GPIO_H_H_H_
N
Ntypedef void (*hfgpio_interrupt_func)(uint32_t,uint32_t);
N//gpio function define
N
N#define HFM_TYPE_LPB100	0
N#define HFM_TYPE_LPT100	1
N#define HFM_TYPE_LPT200	2
N#define HFM_TYPE_LPB105	3
N
N
N#define HFM_PIN_NUMBER		(48)
N
N#define HFM_MAX_FUNC_CODE	(HFM_PIN_NUMBER*2)
N
Nenum HF_GPIO_FUNC_E
N{
N	//////fix/////////////////////
N	HFGPIO_F_JTAG_TCK=0,
N	HFGPIO_F_JTAG_TDO=1,
N	HFGPIO_F_JTAG_TDI,
N	HFGPIO_F_JTAG_TMS,
N	HFGPIO_F_USBDP,
N	HFGPIO_F_USBDM,
N	HFGPIO_F_UART0_TX,
N	HFGPIO_F_UART0_RTS,
N	HFGPIO_F_UART0_RX,
N	HFGPIO_F_UART0_CTS,
N	HFGPIO_F_SPI_MISO,
N	HFGPIO_F_SPI_CLK,
N	HFGPIO_F_SPI_CS,
N	HFGPIO_F_SPI_MOSI,
N	HFGPIO_F_UART1_TX,
N	HFGPIO_F_UART1_RTS,
N	HFGPIO_F_UART1_RX,
N	HFGPIO_F_UART1_CTS,
N	////////////////////////////////
N	HFGPIO_F_NLINK,
N	HFGPIO_F_NREADY,
N	HFGPIO_F_NRELOAD,
N	HFGPIO_F_SLEEP_RQ,
N	HFGPIO_F_SLEEP_ON,
N	HFGPIO_F_WPS,
N	HFGPIO_F_IR,
N	HFGPIO_F_RESERVE2,
N	HFGPIO_F_RESERVE3,
N	HFGPIO_F_RESERVE4,
N	HFGPIO_F_RESERVE5,
N//	HFGPIO_F_USER_DEFINE,
N	
N	HFGPIO_F_K1,
N	HFGPIO_F_K2,
N	HFGPIO_F_K3,
N
N	HFGPIO_F_IA,
N	HFGPIO_F_IB,
N
N	HFGPIO_F_STATE,
N	HFGPIO_F_PWM2,
N	HFGPIO_F_PWM3,
N
N	HFGPIO_F_AD1,
N	HFGPIO_F_AD2
N};
N
N#define F_GPI			(0x00010000)
N#define F_GPO			(0x00020000)
N//GND
N#define F_GND			(0x00040000)
N//use to Peripherals interface
N#define F_PI			(0x00080000)
N//vcc
N#define F_VCC			(0x00100000)
N#define F_NC			(0x00200000)
N//use to system reset
N#define F_RST			(0x00400000)
N//use to interrupt input pin
N#define F_IT			(0x00800000|F_GPI)
N
N#define F_GPIO			(F_GPI|F_GPO)
N
N#define F_PWM			(0x01000000)
N
N#define F_ADC			(0x02000000)
N
N#define HFM_NOPIN			(0)
N#define HFM_PIN1			(F_GND|1)
N#define HFM_PIN2			(F_PI|2)
N#define HFM_PIN3			(F_PI|3)
N#define HFM_PIN4			(F_PI|4)
N#define HFM_PIN5			(F_PI|5)
N#define HFM_PIN6			(F_NC|6)
N#define HFM_PIN7			(F_GPIO|F_IT|F_ADC|7)
N#ifdef __LPB100U__
S#define HFM_PIN8			(F_GPIO|F_IT|F_PWM|F_ADC|8)
N#else
N#define HFM_PIN8			(F_GPIO|F_IT|F_ADC|8)
N#endif
N#define HFM_PIN9			(F_VCC|9)
N#define HFM_PIN10			(F_NC|10)
N#ifdef __LPB100U__
S#define HFM_PIN11			(F_NC|11)
S#define HFM_PIN12			(F_NC|12)
S#define HFM_PIN13			(F_NC|13)
N#else
N#define HFM_PIN11			(F_GPIO|F_IT|F_PWM|F_ADC|11)
N#define HFM_PIN12			(F_GPIO|F_IT|F_PWM|F_ADC|12)
N#define HFM_PIN13			(F_GPIO|F_IT|13)
N#endif
N#define HFM_PIN14			(F_NC|14)
N#define HFM_PIN15			(F_GPIO|F_IT|F_PI|15)
N#define HFM_PIN16			(F_NC|16)
N#define HFM_PIN17			(F_GND|17)
N#define HFM_PIN18			(F_GPIO|F_IT|F_PWM|18)
N#define HFM_PIN19			(F_NC|19)
N#define HFM_PIN20			(F_GPIO|F_IT|F_PWM|20)
N#define HFM_PIN21			(F_NC|21)
N#define HFM_PIN22			(F_NC|22)
N#ifdef __LPB100U__
S#define HFM_PIN23			(F_NC|23)
S#define HFM_PIN24			(F_NC|24)
S#define HFM_PIN25			(F_GPIO|F_IT|F_PI|25)
S#define HFM_PIN26			(F_GPIO|F_IT|F_PI|26)
S#define HFM_PIN27			(F_GPIO|F_IT|F_PI|F_PWM|F_ADC|27)
S#define HFM_PIN28			(F_NC|28)
S#define HFM_PIN29			(F_GPIO|F_IT|F_PI|F_PWM|F_ADC|29)
S#define HFM_PIN30			(F_GPIO|F_IT|F_PI|F_PWM|F_ADC|30)
N#else
N#define HFM_PIN23			(F_GPIO|F_IT|F_PWM|F_ADC|23)
N#define HFM_PIN24			(F_NC|24)
N#define HFM_PIN25			(F_NC|25)
N#define HFM_PIN26			(F_NC|26)
N#define HFM_PIN27			(F_PI|F_GPIO|F_IT|F_ADC|27)
N#define HFM_PIN28			(F_PI|F_GPIO|F_IT|28)
N#define HFM_PIN29			(F_PI|F_GPIO|F_IT|F_ADC|29)
N#define HFM_PIN30			(F_GPIO|F_IT|F_PI|30)
N#endif
N#define HFM_PIN31			(F_VCC|31)
N#define HFM_PIN32			(F_GND|32)
N#define HFM_PIN33			(F_NC|33)
N#define HFM_PIN34			(F_VCC|34)
N#ifdef __LPB100U__
S#define HFM_PIN35			(F_GPIO|F_IT|35)
N#else
N#define HFM_PIN35			(F_NC|35)
N#endif
N#define HFM_PIN36			(F_NC|36)
N#define HFM_PIN37			(F_NC|37)
N#define HFM_PIN38			(F_NC|38)
N#define HFM_PIN39			(F_PI|F_GPIO|F_IT|39)
N#define HFM_PIN40			(F_PI|F_GPIO|F_IT|40)
N#define HFM_PIN41			(F_PI|F_GPIO|F_IT|41)
N#ifdef __LPB100U__
S#define HFM_PIN42			(F_GPIO|F_IT|F_PI|F_PWM|42)
S#define HFM_PIN43			(F_GPIO|F_IT|F_PWM|F_ADC|43)
S#define HFM_PIN44			(F_GPIO|F_IT|F_PWM|F_ADC|44)
S#define HFM_PIN45			(F_GPIO|F_IT|F_PWM|45)
N#else
N#define HFM_PIN42			(F_PI|F_GPIO|F_IT|42)
N#define HFM_PIN43			(F_GPIO|F_IT|43)
N#define HFM_PIN44			(F_GPIO|F_IT|44)
N#define HFM_PIN45			(F_GPIO|F_IT|45)
N#endif
N#define HFM_PIN46			(F_NC|46)
N#define HFM_PIN47			(F_RST|47)
N#define HFM_PIN48			(F_GND|48)
N
N#define HF_M_PINNO(_pin)	((_pin)&0xFF)
N
N#define HFM_VALID_PINNO(_pinno)	((_pinno)>0&&(_pinno)<=HFM_PIN_NUMBER)
N
N#define HF_M_PIN(_no)		HFM_PIN##_no
N
N#define HFM_PIN_NUM		(48)
N
N/*  Default pin configuration (no attribute). */
N#define HFPIO_DEFAULT               (0u << 0)
N/*  The internal pin pull-up is active. */
N#define HFPIO_PULLUP                  (1u << 0)
N
N#ifdef CONFIG_CHIP_SAM4SXX
S/*  The internal glitch filter is active. */
S#define HFPIO_DEGLITCH               (1u << 1)
S/*  The pin is open-drain. */
S#define HFPIO_OPENDRAIN            (1u << 2)
S
S/*  The internal debouncing filter is active. */
S#define HFPIO_DEBOUNCE                (1u << 3)
S
S/*  Enable additional interrupt modes. */
S#define HFPIO_IT_AIME                 (1u << 4)
S
S/*  Interrupt High Level/Rising Edge detection is active. */
S#define HFPIO_IT_RE_OR_HL             (1u << 5)
S/*  Interrupt Edge detection is active. */
S#define HFPIO_IT_EDGE                     (1u << 6)
S
S/*  Low level interrupt is active */
S#define HFPIO_IT_LOW_LEVEL            (0               | 0 | HFPIO_IT_AIME)
S/*  High level interrupt is active */
S#define HFPIO_IT_HIGH_LEVEL           (HFPIO_IT_RE_OR_HL | 0 | HFPIO_IT_AIME)
S/*  Falling edge interrupt is active */
S#define HFPIO_IT_FALL_EDGE            (0               | HFPIO_IT_EDGE | HFPIO_IT_AIME)
S/*  Rising edge interrupt is active */
S#define HFPIO_IT_RISE_EDGE            (HFPIO_IT_RE_OR_HL | HFPIO_IT_EDGE | HFPIO_IT_AIME)
S
S#define HFPIO_TYPE_Pos                27
S/* PIO Type Mask */
S#define HFPIO_TYPE_Msk                (0xFu << HFPIO_TYPE_Pos)
S
S/*   The pin is an input. */
S#define   HFM_IO_TYPE_INPUT       (0x5u << HFPIO_TYPE_Pos)
S/*   The pin is an output and has a default level of 0.*/
S#define   HFM_IO_OUTPUT_0         (0x6u << HFPIO_TYPE_Pos)
S/*   The pin is an output and has a default level of 1.*/
S#define   HFM_IO_OUTPUT_1         (0x7u << HFPIO_TYPE_Pos)
S
S#define   HFPIO_DS				  (0x8u << HFPIO_TYPE_Pos)
N#elif defined(CONFIG_CHIP_HFO18)
X#elif 1L
N
N#define HFPIO_PULLDOWN                  (1u << 1)
N
N/*  Low level interrupt is active */
N#define	HFPIO_IT_LOW_LEVEL          (1u<<4)
N/*  High level interrupt is active */
N#define HFPIO_IT_HIGH_LEVEL	    (1u<<5)
N/*  Falling edge interrupt is active */
N#define HFPIO_IT_FALL_EDGE            (1u<<6)
N/*  Rising edge interrupt is active */
N#define HFPIO_IT_RISE_EDGE             (1u<<7)
N/*Interrupt Edge detection is active.*/
N#define HFPIO_IT_EDGE			    (1u<<8)
N
N#define HFPIO_TYPE_Pos                27
N/* PIO Type Mask */
N#define HFPIO_TYPE_Msk                (0x7u << HFPIO_TYPE_Pos)
N
N/*   The pin is an input. */
N#define   HFM_IO_TYPE_INPUT       (0x01 << HFPIO_TYPE_Pos)
N/*   The pin is an output and has a default level of 0.*/
N#define   HFM_IO_OUTPUT_0          (0x02 << HFPIO_TYPE_Pos)
N/*   The pin is an output and has a default level of 1.*/
N#define   HFM_IO_OUTPUT_1          (0x04 << HFPIO_TYPE_Pos)
N#define   HFPIO_DS				  (0x8u << HFPIO_TYPE_Pos)
N
N#endif
N
N//内部使用函数
N#if defined(CONFIG_CHIP_HFO18)&&defined(__BUILD_HSF_SDK__)
X#if 1L&&0L
S
Svoid HSF_IAPI SetGpioOutput(int bank, int pin);
Svoid HSF_IAPI SetGpioInput(int bank, int pin);
Svoid HSF_IAPI SetGpioNoPull(int bank, int pin);
Svoid HSF_IAPI SetGpioPullUp(int bank, int pin);
Svoid HSF_IAPI SetGpioPullDown(int bank, int pin);
Svoid HSF_IAPI Set_Gpio_High(int bank, int pin);
Svoid HSF_IAPI Set_Gpio_Low(int bank, int pin);
Svoid HSF_IAPI SetGpioNoInputOutput(int bank, int pin);
Svoid HSF_IAPI Set_Gpio_DS(int bank, int pin, int enable);
S
S
N#endif
N
N/*
N *根据功能码设置PIN
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: fid非法,或者它对应的PIN脚非法
N *@HF_FAIL:设置失败
N *@HF_E_ACCES:要配置的PIN不能配置成直到的flags，例如GND,VCC PIN脚,
N			  只能做输入的脚不能配置成输出等.
N*/
Nint HSF_API hfgpio_configure_fpin(int fid,int flags);
Xint  hfgpio_configure_fpin(int fid,int flags);
N
Nint HSF_API hfgpio_fconfigure_get(int fid);
Xint  hfgpio_fconfigure_get(int fid);
N
Nint HSF_API hfgpio_fpin_add_feature(int fid,int flags);
Xint  hfgpio_fpin_add_feature(int fid,int flags);
N
Nint HSF_API hfgpio_fpin_clear_feature(int fid,int flags);
Xint  hfgpio_fpin_clear_feature(int fid,int flags);
N
N/*
N *根据功能码设置对应PIN为输出高电平
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: fid非法,或者它对应的PIN脚非法
N *@HF_FAIL:设置失败
N*/
N//int hfgpio_fset_out_high(int fid);
N#define hfgpio_fset_out_high(__fid)	hfgpio_configure_fpin(__fid,HFPIO_DEFAULT|HFM_IO_OUTPUT_1)
N/*
N *根据功能码设置对应PIN为输出低电平
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: fid非法,或者它对应的PIN脚非法
N *@HF_FAIL:设置失败
N*/
N
N//int hfgpio_fset_out_low(int fid);
N#define hfgpio_fset_out_low(__fid)	hfgpio_configure_fpin(__fid,HFPIO_DEFAULT|HFM_IO_OUTPUT_0)
N
N
N/*
N *根据PIN脚ID设置PIN(内部使用，外部请使用hfgpio_configure_fpin)
N *flags:
N		HFPIO_IT_LOW_LEVEL:低电平触发
N		HFPIO_IT_HIGH_LEVEL:高电平触发
N		HFPIO_IT_FALL_EDGE:下降沿触发
N		HFPIO_IT_RISE_EDGE:上升沿触发
N		HFPIO_IT_EDGE:边沿触发
N *handle:
N		中断触发的时候调用，函数里面不能用延时，处理时间近可能短 		
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: pid非法
N *@HF_FAIL:设置失败
N *@HF_E_ACCES:要配置的PIN不能配置成中断，PIN脚不具备F_IT属性,
N*/
Nint hfgpio_configure_fpin_interrupt(int fid,uint32_t flags,hfgpio_interrupt_func handle,int enable);
N
N/*
N *使能中断,在使能中断之前一定要先调用hfgpio_configure_fpin_interrupt
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: fid非法,或者它对应的PIN脚非法
N *@HF_FAIL:设置失败
N*/
Nint hfgpio_fenable_interrupt(int fid);
N
N/*
N *禁止中断
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_E_INVAL: fid非法,或者它对应的PIN脚非法
N *@HF_FAIL:设置失败
N*/
Nint hfgpio_fdisable_interrupt(int fid);
N
N/*
N *禁止所有的GPIO 中断
N *return value:
N *@HF_SUCCESS:设置成功
N *@HF_FAIL:设置失败
N*/
Nint HSF_API hfgpio_disabel_all_interrupt(void);
Xint  hfgpio_disabel_all_interrupt(void);
N
N/*
N *功能码对应PIN是否为高电平
N *return value:
N *@>=1:高电平
N *@<=0:低电平,或者fid非法，fid对应的pin脚没有定义或者不是gpio
N*/
Nint hfgpio_fpin_is_high(int fid);
N
N/*
N *检查功能码到PIN脚映射表合法行，HFGPIO_F_JTAG_TCK~HFGPIO_F_UART1_CTS，只能配置固定
N *的PIN脚，或者HFM_NOPIN,一个PIN脚只能对应一个功能码。
N *return value:
N *@1:固定功能码映射的PIN脚错误
N *@2:表中存在两个功能码对应同一个PIN脚
N *@0:合法
N*/
Nint hfgpio_fmap_check(int type);
N
N#ifdef __BUILD_HSF_SDK__
S
S/*
S *根据PIN脚ID设置PIN(内部使用，外部请使用hfgpio_configure_fpin)
S *return value:
S *@HF_SUCCESS:设置成功
S *@HF_E_INVAL: pid非法
S *@HF_FAIL:设置失败
S *@HF_E_ACCES:要配置的PIN不能配置成直到的flags，例如GND,VCC PIN脚,
S			  ,只能做输入的脚不能配置成输出等.
S*/
Sint HSF_IAPI hfgpio_configure_pin(int pid,int flags);
S
S#define  hfgpio_set_out_high(pid)	hfgpio_configure_pin(pid,HFPIO_DEFAULT|HFM_IO_OUTPUT_1)
S
S#define  hfgpio_set_out_low(pid)	hfgpio_configure_pin(pid,HFPIO_DEFAULT|HFM_IO_OUTPUT_0)
S
Sint HSF_IAPI hfgpio_get_pid(int pin_no);
S
Svoid HSF_IAPI hfgpio_init_gpio_pin(void);
S
Sint HSF_IAPI hfgpio_pin_is_high(int pid);
S
N#endif
N
N
N//PWM
Nint HSF_API  hfgpio_pwm_disable(int fid);
Xint   hfgpio_pwm_disable(int fid);
N
Nint HSF_API hfgpio_pwm_enable(int fid, int freq, int hrate);
Xint  hfgpio_pwm_enable(int fid, int freq, int hrate);
N
N//ADC
Nint HSF_API hfgpio_adc_enable(int fid);
Xint  hfgpio_adc_enable(int fid);
N
Nint  HSF_API  hfgpio_adc_get_value(int fid);
Xint    hfgpio_adc_get_value(int fid);
N
N
N
N#endif
N
L 62 "..\sdk\1.50\include\hsf.h" 2
N#include "hfspi.h"
L 1 "..\sdk\1.50\include\hfspi.h" 1
N
N#ifndef _HF_SPI_H_H_H_
N#define _HF_SPI_H_H_H_
N
N#define	HFSPIM_CLK_DIV_24M		0x0		/**< SPI master clock Div 24MHz*/
N#define	HFSPIM_CLK_DIV_12M		0x1		/**< SPI master clock Div 12MHz*/
N#define	HFSPIM_CLK_DIV_6M			0x2		/**< SPI master clock Div 6MHz*/
N#define	HFSPIM_CLK_DIV_3M			0x3		/**< SPI master clock Div 3MHz*/
N#define	HFSPIM_CLK_DIV_1M5		0x4		/**< SPI master clock Div 1.5MHz*/
N#define	HFSPIM_CLK_DIV_750K		0x5		/**< SPI master clock Div 750KHz*/
N#define	HFSPIM_CLK_DIV_325K		0x6		/**< SPI master clock Div 325KHz*/
N
N#define HFSPI_MODE_CPOL0_CPHA0		(0)
N#define HFSPI_MODE_CPOL0_CPHA1		(1)
N#define HFSPI_MODE_CPOL1_CPHA0		(2)
N#define HFSPI_MODE_CPOL1_CPHA1		(3)
N
N
Nint HSF_API hfspi_master_init(uint8_t mode, uint8_t clk_div);
Xint  hfspi_master_init(uint8_t mode, uint8_t clk_div);
N
Nint HSF_API hfspi_master_send_data(char* send_buf, uint32_t length);
Xint  hfspi_master_send_data(char* send_buf, uint32_t length);
N
Nint HSF_API hfspi_master_recv_data(char* buf,uint32_t length);
Xint  hfspi_master_recv_data(char* buf,uint32_t length);
N
Nvoid HSF_API hfspi_cs_low(void);
Xvoid  hfspi_cs_low(void);
N
Nvoid HSF_API hfspi_cs_high(void);
Xvoid  hfspi_cs_high(void);
N
N#endif
N
N
L 63 "..\sdk\1.50\include\hsf.h" 2
N#include "hfthread.h"
L 1 "..\sdk\1.50\include\hfthread.h" 1
N
N/* hfthread.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef _H_HF_THREAD_H_H_
N#define _H_HF_THREAD_H_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define HFTHREAD_PRIORITIES_LOW		(1)
N
N#define HFTHREAD_PRIORITIES_MID		(2)
N
N#define HFTHREAD_PRIORITIES_NORMAL	(3)
N
N#define HFTHREAD_PRIORITIES_HIGH		(4)
N
N#define HFTHREAD_MAX_PRIORITIES		(5)
N
Ntypedef void * hfthread_hande_t;
Ntypedef void (*PHFTHREAD_START_ROUTINE)( void * );
N
Nvoid hf_thread_delay(uint32_t ms);
N
Nint HSF_IAPI hfthread_module_init(void);
Xint  hfthread_module_init(void);
N
N
Nint HSF_API hfthread_create(PHFTHREAD_START_ROUTINE routine,const char * const name, uint16_t stack_depth, void *parameters, uint32_t uxpriority, hfthread_hande_t *created_thread, uint32_t *stack_buffer);
Xint  hfthread_create(PHFTHREAD_START_ROUTINE routine,const char * const name, uint16_t stack_depth, void *parameters, uint32_t uxpriority, hfthread_hande_t *created_thread, uint32_t *stack_buffer);
N
Nvoid HSF_API hfthread_destroy(hfthread_hande_t thread);
Xvoid  hfthread_destroy(hfthread_hande_t thread);
N
Nint HSF_API hfthread_enable_softwatchdog(hfthread_hande_t thread,uint32_t time);
Xint  hfthread_enable_softwatchdog(hfthread_hande_t thread,uint32_t time);
N
Nint HSF_API hfthread_disable_softwatchdog(hfthread_hande_t thread);
Xint  hfthread_disable_softwatchdog(hfthread_hande_t thread);
N
Nint HSF_API hfthread_reset_softwatchdog(hfthread_hande_t thread);
Xint  hfthread_reset_softwatchdog(hfthread_hande_t thread);
N
Nint HSF_IAPI hfthread_softwatchdog_check(void);
Xint  hfthread_softwatchdog_check(void);
N
Nvoid HSF_API hfthread_suspend_all(void);
Xvoid  hfthread_suspend_all(void);
N
Nvoid HSF_API hfthread_resume_all(void);
Xvoid  hfthread_resume_all(void);
N
N
N#ifndef msleep
N#define msleep(ms)	hf_thread_delay(ms)
N#endif
N
N#ifndef sleep
N#define sleep(_s)	msleep((_s)*1000)
N#endif
N
Ntypedef void* hfthread_mutex_t;
Ntypedef void* hfthread_sem_t;
N
N#define NULL_MUTEX	(hfthread_mutex_t)0
N
Nint HSF_API hfthread_mutext_new(hfthread_mutex_t *mutex);
Xint  hfthread_mutext_new(hfthread_mutex_t *mutex);
Nvoid HSF_API hfthread_mutext_free(hfthread_mutex_t mutex);
Xvoid  hfthread_mutext_free(hfthread_mutex_t mutex);
Nvoid HSF_API hfthread_mutext_unlock(hfthread_mutex_t mutex);
Xvoid  hfthread_mutext_unlock(hfthread_mutex_t mutex);
Nint HSF_API hfthread_mutext_wait(hfthread_mutex_t mutex, uint32_t timeout);
Xint  hfthread_mutext_wait(hfthread_mutex_t mutex, uint32_t timeout);
Nint HSF_API hfthread_mutext_trylock(hfthread_mutex_t mutex);
Xint  hfthread_mutext_trylock(hfthread_mutex_t mutex);
N
N
Nint HSF_API hfthread_sem_new(hfthread_sem_t *psem,uint8_t cnt);
Xint  hfthread_sem_new(hfthread_sem_t *psem,uint8_t cnt);
Nvoid HSF_API hfthread_sem_free(hfthread_sem_t sem);
Xvoid  hfthread_sem_free(hfthread_sem_t sem);
Nvoid HSF_API hfthread_sem_signal(hfthread_sem_t sem);
Xvoid  hfthread_sem_signal(hfthread_sem_t sem);
Nint HSF_API hfthread_sem_wait(hfthread_sem_t sem, uint32_t timeout);
Xint  hfthread_sem_wait(hfthread_sem_t sem, uint32_t timeout);
N
N
N#define hfthread_mutext_lock(_mu)	hfthread_mutext_wait(_mu,0)
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 64 "..\sdk\1.50\include\hsf.h" 2
N#include "hfnet.h"
L 1 "..\sdk\1.50\include\hfnet.h" 1
N
N
N/* hfnet.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N#ifndef _HF_NET_H_H_H_
N#define _HF_NET_H_H_H_
N
N#include "hsf.h"
L 1 "..\sdk\1.50\include\hsf.h" 1
N
N/* hsf.h
N *
N * Copyright (C) 2013 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef _HSF_H_H_H_H_H_
S#define _HSF_H_H_H_H_H_
S
S#include "hfconfig.h"
S
S#ifdef _ATMEL_ASF_
S#include <asf.h>
S#endif
S
S#if defined   ( __CC_ARM   )
S#	define USER_FUNC	//__attribute__ ((section(".appmain")))
S#	define HSF_API		//__attribute__ ((section(".appmain")))
S#elif defined (  __GNUC__  )
S#   define USER_FUNC __attribute__((section(".appmain")))
S#	define HSF_API		__attribute__ ((section(".appmain")))
S#else
S#define USER_FUNC
S#endif
S
S#define HSF_IAPI		HSF_API
S
S#define _HSF_INLINE_	inline
S
S#ifndef bzero
S#define bzero(_ptr,_size)	memset(_ptr,0,_size)
S#endif
S
S#ifdef __BUILD_HSF_SDK__
S
S#ifdef CONFIG_CHIP_HFO18
S#include <os/os.h>
S#include "driver/gpio.h"
S#endif
S
S#ifdef CONFIG_FREERTOS
S#include <FreeRTOS.h>
S
S	#ifndef NORMAL_FREERTOS
S#define pvPortMalloc(size) OSMalloc(size, MMM_ALLOC_NORMAL)
S#define vPortFree(ptr) OSFree(ptr)
S	#endif
S	
S#endif
S
S#endif
S
S#include "hftypes.h"
S#include "hfsys.h"
S#include "hferrno.h"
S#include "hf_debug.h"
S#include "hfat.h"
S#include "hfgpio.h"
S#include "hfspi.h"
S#include "hfthread.h"
S#include "hfnet.h"
S#include "hfuart.h"
S#include "hfusb.h"
S#include "hftimer.h"
S#include "hftime.h"
S#include "hffile.h"
S#include "hfupdate.h"
S#include "hfflash.h"
S#include "hfflashlayout.h"
S#include <hfir.h>
S#include <hfwifi.h>
S#include <hfsmtlk.h>
S#ifdef __LPB100U__
S#include <hfusbhosthcd.h>
S#include <hfaudio.h>
S#endif
S
N#endif
N
N
L 17 "..\sdk\1.50\include\hfnet.h" 2
N#include "lwip/sockets.h"
L 1 "..\sdk\1.50\include\lwip/sockets.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N
N
N#ifndef __LWIP_SOCKETS_H__
N#define __LWIP_SOCKETS_H__
N
N#include "lwip/opt.h"
L 1 "..\sdk\1.50\include\lwip/opt.h" 1
N/**
N * @file
N *
N * lwIP Options Configuration
N */
N
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_OPT_H__
N#define __LWIP_OPT_H__
N
N/*
N * Include user defined options first. Anything not defined in these files
N * will be set to standard values. Override anything you dont like!
N */
N#include "lwipopts.h"
L 1 "..\sdk\1.50\include\lwipopts.h" 1
N/*****************************************************************************
N*
N* \file
N*
N* \brief lwIP configuration for SAM.
N*
N* Copyright (c) 2012 Atmel Corporation. All rights reserved.
N*
N* \asf_license_start
N*
N* \page License
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions are met:
N*
N* 1. Redistributions of source code must retain the above copyright notice,
N*    this list of conditions and the following disclaimer.
N*
N* 2. Redistributions in binary form must reproduce the above copyright notice,
N*    this list of conditions and the following disclaimer in the documentation
N*    and/or other materials provided with the distribution.
N*
N* 3. The name of Atmel may not be used to endorse or promote products derived
N*    from this software without specific prior written permission.
N*
N* 4. This software may only be redistributed and used in connection with an
N*    Atmel microcontroller product.
N*
N* THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
N* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N* EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N*
N* \asf_license_stop
N*
N*****************************************************************************/
N
N#ifndef __LWIPOPTS_H__
N#define __LWIPOPTS_H__
N
N/* Include user defined options first */
N// #include "conf_eth.h"
N#include "conf_lwip_threads.h"
L 1 "..\sdk\1.50\include\conf_lwip_threads.h" 1
N/**************************************************************************
N *
N * \file
N *
N * \brief lwIP core & application threads configuration file.
N *
N * This file contains the possible external configuration of the Ethernet module.
N *
N * Copyright (c) 2012 Atmel Corporation. All rights reserved.
N *
N * \asf_license_start
N *
N * \page License
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N *
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N *
N * 3. The name of Atmel may not be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * 4. This software may only be redistributed and used in connection with an
N *    Atmel microcontroller product.
N *
N * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N * \asf_license_stop
N *
N ***************************************************************************/
N
N#ifndef _CONF_LWIP_THREADS_H_
N#define _CONF_LWIP_THREADS_H_
N
N//#include "board.h"
N
N/*! define stack size for WEB server task */
N#define lwipBASIC_WEB_SERVER_STACK_SIZE   1024
N
N/*! define stack size for TFTP server task */
N#define lwipBASIC_TFTP_SERVER_STACK_SIZE  2048
N
N/*! define stack size for SMTP Client task */
N#define lwipBASIC_SMTP_CLIENT_STACK_SIZE  256
N
N/*! define stack size for lwIP task */
N#define lwipINTERFACE_STACK_SIZE         2048+1024
N
N/*! define stack size for netif task */
N#define netifINTERFACE_TASK_STACK_SIZE    1024+1024
N
N/*! define WEB server priority */
N#define lwipBASIC_WEB_SERVER_PRIORITY     (tskIDLE_PRIORITY + 2)
N
N/*! define TFTP server priority */
N#define lwipBASIC_TFTP_SERVER_PRIORITY    (tskIDLE_PRIORITY + 3)
N
N/*! define SMTP Client priority */
N#define lwipBASIC_SMTP_CLIENT_PRIORITY    (tskIDLE_PRIORITY + 5)
N
N/*! define lwIP task priority */
N#define lwipINTERFACE_TASK_PRIORITY       (configMAX_PRIORITIES - 2)
N
N/*! define netif task priority */
N#define netifINTERFACE_TASK_PRIORITY      (configMAX_PRIORITIES - 2)
N
N/*! Number of threads that can be started with sys_thread_new() */
N#define SYS_THREAD_MAX                    8
N
N/*! LED used by the ethernet task, toggled on each activation */
N#define webCONN_LED                       LED1_GPIO
N
N#endif /* #ifndef _CONF_LWIP_THREADS_H_ */
L 51 "..\sdk\1.50\include\lwipopts.h" 2
N
N#include "lwip/debug.h"
L 1 "..\sdk\1.50\include\lwip/debug.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEBUG_H__
N#define __LWIP_DEBUG_H__
N
N#include "lwip/arch.h"
L 1 "..\sdk\1.50\include\lwip/arch.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ARCH_H__
N#define __LWIP_ARCH_H__
N
N#ifndef LITTLE_ENDIAN
N#define LITTLE_ENDIAN 1234
N#endif
N
N#ifndef BIG_ENDIAN
N#define BIG_ENDIAN 4321
N#endif
N
N#include "arch/cc.h"
L 1 "..\sdk\1.50\include\arch/cc.h" 1
N/**
N * \file
N *
N * \brief lwIP abstraction layer for SAM.
N *
N * Copyright (c) 2012 Atmel Corporation. All rights reserved.
N *
N * \asf_license_start
N *
N * \page License
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N *
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N *
N * 3. The name of Atmel may not be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * 4. This software may only be redistributed and used in connection with an
N *    Atmel microcontroller product.
N *
N * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
N * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
N * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N * POSSIBILITY OF SUCH DAMAGE.
N *
N * \asf_license_stop
N *
N */
N
N#ifndef CC_H_INCLUDED
N#define CC_H_INCLUDED
N
N/* Define platform endianness */
N#define BYTE_ORDER LITTLE_ENDIAN
N
N/* The unsigned data types */
Ntypedef unsigned char u8_t;
Ntypedef unsigned short u16_t;
Ntypedef unsigned int u32_t;
N
N/* The signed counterparts */
Ntypedef signed char s8_t;
Ntypedef signed short s16_t;
Ntypedef signed int s32_t;
N
N/* A generic pointer type */
Ntypedef u32_t mem_ptr_t;
N
N/* Display name of types */
N#define U16_F           "hu"
N#define S16_F           "hd"
N#define X16_F           "hx"
N#define U32_F           "u"
N#define S32_F           "d"
N#define X32_F           "x"
N
N/* Compiler hints for packing lwip's structures */
N#if defined(__CC_ARM)
X#if 1L
N    /* Setup PACKing macros for MDK Tools */
N#define PACK_STRUCT_BEGIN
N#define PACK_STRUCT_STRUCT __attribute__ ((packed))
N#define PACK_STRUCT_END
N#define PACK_STRUCT_FIELD(x) x
N#elif defined (__ICCARM__)
S    /* Setup PACKing macros for EWARM Tools */
S#define PACK_STRUCT_BEGIN __packed
S#define PACK_STRUCT_STRUCT
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S#elif defined (__GNUC__)
S    /* Setup PACKing macros for GCC Tools */
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT __attribute__ ((packed))
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S#else
S#error "This compiler does not support."
N#endif
N
N/* define LWIP_COMPAT_MUTEX
N    to let sys.h use binary semaphores instead of mutexes - as before in 1.3.2
N    Refer CHANGELOG
N*/
N#define  LWIP_COMPAT_MUTEX  1
N
N#define lwip_printf(...)	HF_Debug(DEBUG_TCPIP,__VA_ARGS__)
N
N#define LWIP_PLATFORM_DIAG(x)	lwip_printf x
N
N#define LWIP_PLATFORM_ASSERT(x) do {/*printf("Assertion \"%s\" failed at line %d in %s\n", x, __LINE__, __FILE__); \
N                                      fflush(NULL); abort();*/} while(1)
X#define LWIP_PLATFORM_ASSERT(x) do { } while(1)
N
N#define LWIP_PROVIDE_ERRNO /* Make lwip/arch.h define the codes which are used throughout */
N
N#endif /* CC_H_INCLUDED */
L 44 "..\sdk\1.50\include\lwip/arch.h" 2
N
N/** Temporary: define format string for size_t if not defined in cc.h */
N#ifndef SZT_F
N#define SZT_F U32_F
N#endif /* SZT_F */
N/** Temporary upgrade helper: define format string for u8_t as hex if not
N    defined in cc.h */
N#ifndef X8_F
N#define X8_F  "02x"
N#endif /* X8_F */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef PACK_STRUCT_BEGIN
S#define PACK_STRUCT_BEGIN
N#endif /* PACK_STRUCT_BEGIN */
N
N#ifndef PACK_STRUCT_END
S#define PACK_STRUCT_END
N#endif /* PACK_STRUCT_END */
N
N#ifndef PACK_STRUCT_FIELD
S#define PACK_STRUCT_FIELD(x) x
N#endif /* PACK_STRUCT_FIELD */
N
N
N#ifndef LWIP_UNUSED_ARG
N#define LWIP_UNUSED_ARG(x) (void)x
N#endif /* LWIP_UNUSED_ARG */ 
N
N
N#ifdef LWIP_PROVIDE_ERRNO
N
N#define  EPERM         1  /* Operation not permitted */
N#define  ENOENT        2  /* No such file or directory */
N#define  ESRCH         3  /* No such process */
N#define  EINTR         4  /* Interrupted system call */
N#define  EIO           5  /* I/O error */
N#define  ENXIO         6  /* No such device or address */
N#define  E2BIG         7  /* Arg list too long */
N#define  ENOEXEC       8  /* Exec format error */
N#define  EBADF         9  /* Bad file number */
N#define  ECHILD       10  /* No child processes */
N#define  EAGAIN       11  /* Try again */
N#define  ENOMEM       12  /* Out of memory */
N#define  EACCES       13  /* Permission denied */
N#define  EFAULT       14  /* Bad address */
N#define  ENOTBLK      15  /* Block device required */
N#define  EBUSY        16  /* Device or resource busy */
N#define  EEXIST       17  /* File exists */
N#define  EXDEV        18  /* Cross-device link */
N#define  ENODEV       19  /* No such device */
N#define  ENOTDIR      20  /* Not a directory */
N#define  EISDIR       21  /* Is a directory */
N#define  EINVAL       22  /* Invalid argument */
N#define  ENFILE       23  /* File table overflow */
N#define  EMFILE       24  /* Too many open files */
N#define  ENOTTY       25  /* Not a typewriter */
N#define  ETXTBSY      26  /* Text file busy */
N#define  EFBIG        27  /* File too large */
N#define  ENOSPC       28  /* No space left on device */
N#define  ESPIPE       29  /* Illegal seek */
N#define  EROFS        30  /* Read-only file system */
N#define  EMLINK       31  /* Too many links */
N#define  EPIPE        32  /* Broken pipe */
N#define  EDOM         33  /* Math argument out of domain of func */
N#define  ERANGE       34  /* Math result not representable */
N#define  EDEADLK      35  /* Resource deadlock would occur */
N#define  ENAMETOOLONG 36  /* File name too long */
N#define  ENOLCK       37  /* No record locks available */
N#define  ENOSYS       38  /* Function not implemented */
N#define  ENOTEMPTY    39  /* Directory not empty */
N#define  ELOOP        40  /* Too many symbolic links encountered */
N#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
N#define  ENOMSG       42  /* No message of desired type */
N#define  EIDRM        43  /* Identifier removed */
N#define  ECHRNG       44  /* Channel number out of range */
N#define  EL2NSYNC     45  /* Level 2 not synchronized */
N#define  EL3HLT       46  /* Level 3 halted */
N#define  EL3RST       47  /* Level 3 reset */
N#define  ELNRNG       48  /* Link number out of range */
N#define  EUNATCH      49  /* Protocol driver not attached */
N#define  ENOCSI       50  /* No CSI structure available */
N#define  EL2HLT       51  /* Level 2 halted */
N#define  EBADE        52  /* Invalid exchange */
N#define  EBADR        53  /* Invalid request descriptor */
N#define  EXFULL       54  /* Exchange full */
N#define  ENOANO       55  /* No anode */
N#define  EBADRQC      56  /* Invalid request code */
N#define  EBADSLT      57  /* Invalid slot */
N
N#define  EDEADLOCK    EDEADLK
N
N#define  EBFONT       59  /* Bad font file format */
N#define  ENOSTR       60  /* Device not a stream */
N#define  ENODATA      61  /* No data available */
N#define  ETIME        62  /* Timer expired */
N#define  ENOSR        63  /* Out of streams resources */
N#define  ENONET       64  /* Machine is not on the network */
N#define  ENOPKG       65  /* Package not installed */
N#define  EREMOTE      66  /* Object is remote */
N#define  ENOLINK      67  /* Link has been severed */
N#define  EADV         68  /* Advertise error */
N#define  ESRMNT       69  /* Srmount error */
N#define  ECOMM        70  /* Communication error on send */
N#define  EPROTO       71  /* Protocol error */
N#define  EMULTIHOP    72  /* Multihop attempted */
N#define  EDOTDOT      73  /* RFS specific error */
N#define  EBADMSG      74  /* Not a data message */
N#define  EOVERFLOW    75  /* Value too large for defined data type */
N#define  ENOTUNIQ     76  /* Name not unique on network */
N#define  EBADFD       77  /* File descriptor in bad state */
N#define  EREMCHG      78  /* Remote address changed */
N#define  ELIBACC      79  /* Can not access a needed shared library */
N#define  ELIBBAD      80  /* Accessing a corrupted shared library */
N#define  ELIBSCN      81  /* .lib section in a.out corrupted */
N#define  ELIBMAX      82  /* Attempting to link in too many shared libraries */
N#define  ELIBEXEC     83  /* Cannot exec a shared library directly */
N#define  EILSEQ       84  /* Illegal byte sequence */
N#define  ERESTART     85  /* Interrupted system call should be restarted */
N#define  ESTRPIPE     86  /* Streams pipe error */
N#define  EUSERS       87  /* Too many users */
N#define  ENOTSOCK     88  /* Socket operation on non-socket */
N#define  EDESTADDRREQ 89  /* Destination address required */
N#define  EMSGSIZE     90  /* Message too long */
N#define  EPROTOTYPE   91  /* Protocol wrong type for socket */
N#define  ENOPROTOOPT  92  /* Protocol not available */
N#define  EPROTONOSUPPORT 93  /* Protocol not supported */
N#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
N#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
N#define  EPFNOSUPPORT    96  /* Protocol family not supported */
N#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
N#define  EADDRINUSE      98  /* Address already in use */
N#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
N#define  ENETDOWN       100  /* Network is down */
N#define  ENETUNREACH    101  /* Network is unreachable */
N#define  ENETRESET      102  /* Network dropped connection because of reset */
N#define  ECONNABORTED   103  /* Software caused connection abort */
N#define  ECONNRESET     104  /* Connection reset by peer */
N#define  ENOBUFS        105  /* No buffer space available */
N#define  EISCONN        106  /* Transport endpoint is already connected */
N#define  ENOTCONN       107  /* Transport endpoint is not connected */
N#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
N#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
N#define  ETIMEDOUT      110  /* Connection timed out */
N#define  ECONNREFUSED   111  /* Connection refused */
N#define  EHOSTDOWN      112  /* Host is down */
N#define  EHOSTUNREACH   113  /* No route to host */
N#define  EALREADY       114  /* Operation already in progress */
N#define  EINPROGRESS    115  /* Operation now in progress */
N#define  ESTALE         116  /* Stale NFS file handle */
N#define  EUCLEAN        117  /* Structure needs cleaning */
N#define  ENOTNAM        118  /* Not a XENIX named type file */
N#define  ENAVAIL        119  /* No XENIX semaphores available */
N#define  EISNAM         120  /* Is a named type file */
N#define  EREMOTEIO      121  /* Remote I/O error */
N#define  EDQUOT         122  /* Quota exceeded */
N
N#define  ENOMEDIUM      123  /* No medium found */
N#define  EMEDIUMTYPE    124  /* Wrong medium type */
N
N
N#define ENSROK                    0 /* DNS server returned answer with no data */
N#define ENSRNODATA              160 /* DNS server returned answer with no data */
N#define ENSRFORMERR             161 /* DNS server claims query was misformatted */
N#define ENSRSERVFAIL            162 /* DNS server returned general failure */
N#define ENSRNOTFOUND            163 /* Domain name not found */
N#define ENSRNOTIMP              164 /* DNS server does not implement requested operation */
N#define ENSRREFUSED             165 /* DNS server refused query */
N#define ENSRBADQUERY            166 /* Misformatted DNS query */
N#define ENSRBADNAME             167 /* Misformatted domain name */
N#define ENSRBADFAMILY           168 /* Unsupported address family */
N#define ENSRBADRESP             169 /* Misformatted DNS reply */
N#define ENSRCONNREFUSED         170 /* Could not contact DNS servers */
N#define ENSRTIMEOUT             171 /* Timeout while contacting DNS servers */
N#define ENSROF                  172 /* End of file */
N#define ENSRFILE                173 /* Error reading file */
N#define ENSRNOMEM               174 /* Out of memory */
N#define ENSRDESTRUCTION         175 /* Application terminated lookup */
N#define ENSRQUERYDOMAINTOOLONG  176 /* Domain name is too long */
N#define ENSRCNAMELOOP           177 /* Domain name is too long */
N
N#ifndef errno
Nextern int errno;
N#endif
N
N#endif /* LWIP_PROVIDE_ERRNO */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ARCH_H__ */
L 36 "..\sdk\1.50\include\lwip/debug.h" 2
N#include "hf_debug.h"
N
N/** lower two bits indicate debug level
N * - 0 all
N * - 1 warning
N * - 2 serious
N * - 3 severe
N */
N#define LWIP_DBG_LEVEL_ALL     0x00
N#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL /* compatibility define only */
N#define LWIP_DBG_LEVEL_WARNING 0x01 /* bad checksums, dropped packets, ... */
N#define LWIP_DBG_LEVEL_SERIOUS 0x02 /* memory allocation failures, ... */
N#define LWIP_DBG_LEVEL_SEVERE  0x03
N#define LWIP_DBG_MASK_LEVEL    0x03
N
N/** flag for LWIP_DEBUGF to enable that debug message */
N#define LWIP_DBG_ON            0x80U
N/** flag for LWIP_DEBUGF to disable that debug message */
N#define LWIP_DBG_OFF           0x00U
N
N/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
N#define LWIP_DBG_TRACE         0x40U
N/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
N#define LWIP_DBG_STATE         0x20U
N/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
N#define LWIP_DBG_FRESH         0x10U
N/** flag for LWIP_DEBUGF to halt after printing this debug message */
N#define LWIP_DBG_HALT          0x08U
N
N#ifndef LWIP_NOASSERT
N#define LWIP_ASSERT(message, assertion) /*do { if(!(assertion)) \
N  LWIP_PLATFORM_ASSERT(message); } while(0)*/
X#define LWIP_ASSERT(message, assertion)  
N#else  /* LWIP_NOASSERT */
S#define LWIP_ASSERT(message, assertion) 
N#endif /* LWIP_NOASSERT */
N
N/** if "expression" isn't true, then print "message" and execute "handler" expression */
N#ifndef LWIP_ERROR
N#define LWIP_ERROR(message, expression, handler) /*do { if (!(expression)) { \
N  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)*/
X#define LWIP_ERROR(message, expression, handler)  
N#endif /* LWIP_ERROR */
N
N#if 1
N//#define LWIP_DEBUG
N#ifdef LWIP_DEBUG
S/** print debug message only if debug message type is enabled...
S *  AND is of correct type AND is at least LWIP_DBG_LEVEL
S */
S#define LWIP_DEBUGF(debug, message) do { \
S                               if ( \
S                                   ((debug) & LWIP_DBG_ON) && \
S                                   ((debug) & LWIP_DBG_TYPES_ON) && \
S                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
S                                 LWIP_PLATFORM_DIAG(message); \
S                                 if ((debug) & LWIP_DBG_HALT) { \
S                                   while(1); \
S                                 } \
S                               } \
S                             } while(0)
X#define LWIP_DEBUGF(debug, message) do {                                if (                                    ((debug) & LWIP_DBG_ON) &&                                    ((debug) & LWIP_DBG_TYPES_ON) &&                                    ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) {                                  LWIP_PLATFORM_DIAG(message);                                  if ((debug) & LWIP_DBG_HALT) {                                    while(1);                                  }                                }                              } while(0)
S
N#else  /* LWIP_DEBUG */
N#define LWIP_DEBUGF(debug, message) 
N#endif /* LWIP_DEBUG */
N#endif
N//#define LWIP_DEBUGF HF_Debug
N
N#endif /* __LWIP_DEBUG_H__ */
N
L 53 "..\sdk\1.50\include\lwipopts.h" 2
N
N/* Define default values for unconfigured parameters. */
N#define LWIP_NOASSERT 1 /* To suppress some errors for now (no debug output) */
N
N/* These two control is reclaimer functions should be compiled
N * in. Should always be turned on (1). */
N#define MEM_RECLAIM             1
N#define MEMP_RECLAIM            1
N
N
N/* Platform specific locking */
N
N/*
N * enable SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
N * for certain critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#define SYS_LIGHTWEIGHT_PROT            1
N
N/* ---------- Memory options ---------- */
N
N/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
N * lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
N * byte alignment -> define MEM_ALIGNMENT to 2. */
N#define MEM_ALIGNMENT           4
N
N/* MEM_SIZE: the size of the heap memory. If the application will send
N * a lot of data that needs to be copied, this should be set high. */
N#define MEM_SIZE                6 * 1024
N
N/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
N * sends a lot of data out of ROM (or other static memory), this
N * should be set high. */
N#define MEMP_NUM_PBUF           6
N
N/* Number of raw connection PCBs */
N#define MEMP_NUM_RAW_PCB                1
N
N/* ---------- UDP options ---------- */
N  #define LWIP_UDP                1
N  #define UDP_TTL                 255
N
N/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N * per active UDP "connection". */
N
N/* required by DHCP (because DNS is used) */
N  #define MEMP_NUM_UDP_PCB        (6+2) // 4 // 1
N
N#if (TFTP_USED == 1)
S
S/* one PCB for DHCP (DNS used), one for TFTP */
S  #undef MEMP_NUM_UDP_PCB
S  #define MEMP_NUM_UDP_PCB       4// 2
S
N#endif
N
N/* MEMP_NUM_TCP_PCB: the number of simultaneously active TCP connections. */
N#define MEMP_NUM_TCP_PCB      ( 5+4+2)// 2
N/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections. */
N#define MEMP_NUM_TCP_PCB_LISTEN	2// 1
N/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments. */
N#define MEMP_NUM_TCP_SEG        9
N/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts. */
N#define MEMP_NUM_SYS_TIMEOUT    6+4
N
N/* The following four are used only with the sequential API and can be
N * set to 0 if the application only will use the raw API. */
N/* MEMP_NUM_NETBUF: the number of struct netbufs. */
N#define MEMP_NUM_NETBUF         (4+4)
N/* MEMP_NUM_NETCONN: the number of struct netconns. */
N#define MEMP_NUM_NETCONN        (5+4+2) // 2 for uart select
N
N/* ---------- Pbuf options ---------- */
N/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
N
N#define PBUF_POOL_SIZE          20//6
N
N/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
N
N#define PBUF_POOL_BUFSIZE       500
N
N/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
N * alignment of payload after that header. Since the header is 14 bytes long,
N * without this padding e.g. addresses in the IP header will not be aligned
N * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
N */
N#define ETH_PAD_SIZE                    0
N
N/* PBUF_LINK_HLEN: the number of bytes that should be allocated for a
N * link level header. */
N#define PBUF_LINK_HLEN          (16 + ETH_PAD_SIZE)
N
N/* ---------- TCP options ---------- */
N#define LWIP_TCP                1
N#define TCP_TTL                 255
N/* TCP receive window. */
N#define TCP_WND                 1500
N
N/* Controls if TCP should queue segments that arrive out of
N * order. Define to 0 if your device is low on memory. */
N#define TCP_QUEUE_OOSEQ         1
N
N/* TCP Maximum segment size. */
N#define TCP_MSS                 1400
N
N/* TCP sender buffer space (bytes). */
N#define TCP_SND_BUF             5*TCP_MSS	//2150
N
N/* TCP sender buffer space (pbufs). This must be at least = 2 *
N   TCP_SND_BUF/TCP_MSS for things to work. */
N#define TCP_SND_QUEUELEN        12//((6 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
N
N
N
N/* Maximum number of retransmissions of data segments. */
N#define TCP_MAXRTX              12
N
N/* Maximum number of retransmissions of SYN segments. */
N#define TCP_SYNMAXRTX           4
N
N/**
N * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#define DEFAULT_RAW_RECVMBOX_SIZE       6
N
N/**
N * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#define DEFAULT_UDP_RECVMBOX_SIZE       6
N
N/**
N * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#define DEFAULT_TCP_RECVMBOX_SIZE       25//6
N
N/**
N * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when the acceptmbox is created.
N */
N#define DEFAULT_ACCEPTMBOX_SIZE         6
N
N/* ---------- ARP options ---------- */
N#define ARP_TABLE_SIZE 10
N#define ARP_QUEUEING 0
N
N/* ---------- IP options ---------- */
N
N/* Define IP_FORWARD to 1 if you wish to have the ability to forward
N * IP packets across network interfaces. If you are going to run lwIP
N * on a device with only one network interface, define this to 0. */
N#define IP_FORWARD              0
N
N/* If defined to 1, IP options are allowed (but not parsed). If
N * defined to 0, all packets with IP options are dropped. */
N#define IP_OPTIONS              1
N
N/* ---------- ICMP options ---------- */
N#define ICMP_TTL                255
N
N/* ---------- DHCP options ---------- */
N
N/* Define LWIP_DHCP to 1 if you want DHCP configuration of
N * interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
N * turning this on does currently not work. */
N#define LWIP_DHCP               1
N
N#ifdef LWIP_DHCP
N#define DHCP_USED
N#endif
N
N/* 1 if you want to do an ARP check on the offered address
N * (recommended). */
N/* #define DHCP_DOES_ARP_CHECK     1 */
N
N/*
N * ------------------------------------
N * ---------- Thread options ----------
N * ------------------------------------
N */
N
N/**
N * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
N */
N#define TCPIP_THREAD_NAME              "tcpip_thread"
N
N/**
N * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define TCPIP_THREAD_STACKSIZE          lwipINTERFACE_STACK_SIZE
N
N/**
N * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define TCPIP_THREAD_PRIO               lwipINTERFACE_TASK_PRIORITY
N
N/**
N * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when tcpip_init is called.
N */
N#define TCPIP_MBOX_SIZE                 20//6
N
N/**
N * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
N */
N#define SLIPIF_THREAD_NAME             "slipif"
N
N/**
N * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define SLIPIF_THREAD_STACKSIZE         configMINIMAL_STACK_SIZE
N
N/**
N * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define SLIPIF_THREAD_PRIO              1
N
N/**
N * PPP_THREAD_NAME: The name assigned to the pppMain thread.
N */
N#define PPP_THREAD_NAME                "pppInputThread"
N
N/**
N * PPP_THREAD_STACKSIZE: The stack size used by the pppMain thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define PPP_THREAD_STACKSIZE            configMINIMAL_STACK_SIZE
N
N/**
N * PPP_THREAD_PRIO: The priority assigned to the pppMain thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define PPP_THREAD_PRIO                 1
N
N/**
N * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
N */
N#define DEFAULT_THREAD_NAME            "lwIP"
N
N/**
N * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define DEFAULT_THREAD_STACKSIZE        configMINIMAL_STACK_SIZE
N
N/**
N * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#define DEFAULT_THREAD_PRIO             1
N
N#define LWIP_NETIF_STATUS_CALLBACK      1
N
N/* ---------- Statistics options ---------- */
N#define LWIP_STATS 1
N
N#define LWIP_STATS_DISPLAY 0
N
N#if LWIP_STATS
X#if 1
N#define LINK_STATS 1
N#define IP_STATS   1
N#define ICMP_STATS 1
N#define UDP_STATS  1
N#define TCP_STATS  1
N#define MEM_STATS  1
N#define MEMP_STATS 1
N#define PBUF_STATS 1
N#define SYS_STATS  1
N#endif /* STATS */
N
N/* ---------- Lwip Debug options ---------- */
N
N#define DBG_TYPES_ON                    0xff
N
N#define ETHARP_DEBUG                    LWIP_DBG_OFF
N
N#define NETIF_DEBUG                     LWIP_DBG_OFF
N
N#define PBUF_DEBUG                      LWIP_DBG_OFF
N
N#define API_LIB_DEBUG                   LWIP_DBG_OFF
N
N#define API_MSG_DEBUG                   LWIP_DBG_ON
N
N#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N
N#define ICMP_DEBUG                      LWIP_DBG_OFF
N
N#define INET_DEBUG                      LWIP_DBG_OFF
N
N#define IP_DEBUG                        LWIP_DBG_OFF
N
N#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N
N#define RAW_DEBUG                       LWIP_DBG_OFF
N
N#define MEM_DEBUG                       LWIP_DBG_OFF
N
N#define MEMP_DEBUG                      LWIP_DBG_OFF
N
N#define SYS_DEBUG                       LWIP_DBG_OFF
N
N#define TCP_DEBUG                       LWIP_DBG_OFF
N
N#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N
N#define TCP_FR_DEBUG                    LWIP_DBG_OFF
N
N#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N
N#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N
N#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N
N#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N
N#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N
N#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N
N#define UDP_DEBUG                       LWIP_DBG_OFF
N
N#define TCPIP_DEBUG                     LWIP_DBG_ON
N
N#define DBG_MIN_LEVEL                   LWIP_DBG_LEVEL_SEVERE
N
N#define TCP_CONNECT_DEBUG                       LWIP_DBG_ON
N
N
N/* \note For a list of all possible lwIP configurations, check
N * http://lwip.wikia.com/wiki/Lwipopts.h */
N
N#endif /* __LWIPOPTS_H__ */
L 46 "..\sdk\1.50\include\lwip/opt.h" 2
N#include "lwip/debug.h"
N
N/*
N   -----------------------------------------------
N   ---------- Platform specific locking ----------
N   -----------------------------------------------
N*/
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#ifndef SYS_LIGHTWEIGHT_PROT
S#define SYS_LIGHTWEIGHT_PROT            0
N#endif
N
N/** 
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#ifndef NO_SYS
N#define NO_SYS                          0
N#endif
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#ifndef NO_SYS_NO_TIMERS
N#define NO_SYS_NO_TIMERS                0
N#endif
N
N/**
N * MEMCPY: override this if you have a faster implementation at hand than the
N * one included in your C library
N */
N#ifndef MEMCPY
N#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
N#endif
N
N/**
N * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
N * call to memcpy() if the length is known at compile time and is small.
N */
N#ifndef SMEMCPY
N#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
N#endif
N
N/*
N   ------------------------------------
N   ---------- Memory options ----------
N   ------------------------------------
N*/
N/**
N * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
N * instead of the lwip internal allocator. Can save code size if you
N * already use it.
N */
N#ifndef MEM_LIBC_MALLOC
N#define MEM_LIBC_MALLOC                 0
N#endif
N
N/**
N* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
N* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
N* speed and usage from interrupts!
N*/
N#ifndef MEMP_MEM_MALLOC
N#define MEMP_MEM_MALLOC                 0
N#endif
N
N/**
N * MEM_ALIGNMENT: should be set to the alignment of the CPU
N *    4 byte alignment -> #define MEM_ALIGNMENT 4
N *    2 byte alignment -> #define MEM_ALIGNMENT 2
N */
N#ifndef MEM_ALIGNMENT
S#define MEM_ALIGNMENT                   1
N#endif
N
N/**
N * MEM_SIZE: the size of the heap memory. If the application will send
N * a lot of data that needs to be copied, this should be set high.
N */
N#ifndef MEM_SIZE
S#define MEM_SIZE                        1600
N#endif
N
N/**
N * MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
N * This can be used to individually change the location of each pool.
N * Default is one big array for all pools
N */
N#ifndef MEMP_SEPARATE_POOLS
N#define MEMP_SEPARATE_POOLS             0
N#endif
N
N/**
N * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
N * amount of bytes before and after each memp element in every pool and fills
N * it with a prominent default value.
N *    MEMP_OVERFLOW_CHECK == 0 no checking
N *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
N *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
N *      memp_malloc() or memp_free() is called (useful but slow!)
N */
N#ifndef MEMP_OVERFLOW_CHECK
N#define MEMP_OVERFLOW_CHECK             0
N#endif
N
N/**
N * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
N * sure that there are no cycles in the linked lists.
N */
N#ifndef MEMP_SANITY_CHECK
N#define MEMP_SANITY_CHECK               0
N#endif
N
N/**
N * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
N * of memory pools of various sizes. When mem_malloc is called, an element of
N * the smallest pool that can provide the length needed is returned.
N * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
N */
N#ifndef MEM_USE_POOLS
N#define MEM_USE_POOLS                   0
N#endif
N
N/**
N * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
N * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
N * reliable. */
N#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
N#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
N#endif
N
N/**
N * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
N * that defines additional pools beyond the "standard" ones required
N * by lwIP. If you set this to 1, you must have lwippools.h in your 
N * inlude path somewhere. 
N */
N#ifndef MEMP_USE_CUSTOM_POOLS
N#define MEMP_USE_CUSTOM_POOLS           0
N#endif
N
N/**
N * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
N * interrupt context (or another context that doesn't allow waiting for a
N * semaphore).
N * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
N * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
N * with each loop so that mem_free can run.
N *
N * ATTENTION: As you can see from the above description, this leads to dis-/
N * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
N * can need longer.
N *
N * If you don't want that, at least for NO_SYS=0, you can still use the following
N * functions to enqueue a deallocation call which then runs in the tcpip_thread
N * context:
N * - pbuf_free_callback(p);
N * - mem_free_callback(m);
N */
N#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
N#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Internal Memory Pool Sizes ----------
N   ------------------------------------------------
N*/
N/**
N * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
N * If the application sends a lot of data out of ROM (or other static memory),
N * this should be set high.
N */
N#ifndef MEMP_NUM_PBUF
S#define MEMP_NUM_PBUF                   16
N#endif
N
N/**
N * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
N * (requires the LWIP_RAW option)
N */
N#ifndef MEMP_NUM_RAW_PCB
S#define MEMP_NUM_RAW_PCB                4
N#endif
N
N/**
N * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N * per active UDP "connection".
N * (requires the LWIP_UDP option)
N */
N#ifndef MEMP_NUM_UDP_PCB
S#define MEMP_NUM_UDP_PCB                4
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB
S#define MEMP_NUM_TCP_PCB                5
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB_LISTEN
S#define MEMP_NUM_TCP_PCB_LISTEN         8
N#endif
N
N/**
N * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_SEG
S#define MEMP_NUM_TCP_SEG                16
N#endif
N
N/**
N * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
N * reassembly (whole packets, not fragments!)
N */
N#ifndef MEMP_NUM_REASSDATA
N#define MEMP_NUM_REASSDATA              5
N#endif
N
N/**
N * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
N * (fragments, not whole packets!).
N * This is only used with IP_FRAG_USES_STATIC_BUF==0 and
N * LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
N * where the packet is not yet sent when netif->output returns.
N */
N#ifndef MEMP_NUM_FRAG_PBUF
N#define MEMP_NUM_FRAG_PBUF              15
N#endif
N
N/**
N * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
N * packets (pbufs) that are waiting for an ARP request (to resolve
N * their destination address) to finish.
N * (requires the ARP_QUEUEING option)
N */
N#ifndef MEMP_NUM_ARP_QUEUE
N#define MEMP_NUM_ARP_QUEUE              30
N#endif
N
N/**
N * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
N * can be members et the same time (one per netif - allsystems group -, plus one
N * per netif membership).
N * (requires the LWIP_IGMP option)
N */
N#ifndef MEMP_NUM_IGMP_GROUP
N#define MEMP_NUM_IGMP_GROUP             8
N#endif
N
N/**
N * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
N * (requires NO_SYS==0)
N */
N#ifndef MEMP_NUM_SYS_TIMEOUT
S#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)// 3
N#endif
N
N/**
N * MEMP_NUM_NETBUF: the number of struct netbufs.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETBUF
S#define MEMP_NUM_NETBUF                 2
N#endif
N
N/**
N * MEMP_NUM_NETCONN: the number of struct netconns.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETCONN
S#define MEMP_NUM_NETCONN                4
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
N * for callback/timeout API communication. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_API
N#define MEMP_NUM_TCPIP_MSG_API          8
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
N * for incoming packets. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_INPKT
N#define MEMP_NUM_TCPIP_MSG_INPKT        8
N#endif
N
N/**
N * MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
N */
N#ifndef MEMP_NUM_SNMP_NODE
N#define MEMP_NUM_SNMP_NODE              50
N#endif
N
N/**
N * MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
N * Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
N */
N#ifndef MEMP_NUM_SNMP_ROOTNODE
N#define MEMP_NUM_SNMP_ROOTNODE          30
N#endif
N
N/**
N * MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
N * be changed normally) - 2 of these are used per request (1 for input,
N * 1 for output)
N */
N#ifndef MEMP_NUM_SNMP_VARBIND
N#define MEMP_NUM_SNMP_VARBIND           2
N#endif
N
N/**
N * MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
N * (does not have to be changed normally) - 3 of these are used per request
N * (1 for the value read and 2 for OIDs - input and output)
N */
N#ifndef MEMP_NUM_SNMP_VALUE
N#define MEMP_NUM_SNMP_VALUE             3
N#endif
N
N/**
N * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
N * (before freeing the corresponding memory using lwip_freeaddrinfo()).
N */
N#ifndef MEMP_NUM_NETDB
N#define MEMP_NUM_NETDB                  1
N#endif
N
N/**
N * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
N * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
N */
N#ifndef MEMP_NUM_LOCALHOSTLIST
N#define MEMP_NUM_LOCALHOSTLIST          1
N#endif
N
N/**
N * MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
N * interfaces (only used with PPPOE_SUPPORT==1)
N */
N#ifndef MEMP_NUM_PPPOE_INTERFACES
N#define MEMP_NUM_PPPOE_INTERFACES       1
N#endif
N
N/**
N * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
N */
N#ifndef PBUF_POOL_SIZE
S#define PBUF_POOL_SIZE                  16
N#endif
N
N/*
N   ---------------------------------
N   ---------- ARP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_ARP==1: Enable ARP functionality.
N */
N#ifndef LWIP_ARP
N#define LWIP_ARP                        1
N#endif
N
N/**
N * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
N */
N#ifndef ARP_TABLE_SIZE
S#define ARP_TABLE_SIZE                  10
N#endif
N
N/**
N * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
N * resolution. By default, only the most recent packet is queued per IP address.
N * This is sufficient for most protocols and mainly reduces TCP connection
N * startup time. Set this to 1 if you know your application sends more than one
N * packet in a row to an IP address that is not in the ARP cache.
N */
N#ifndef ARP_QUEUEING
S#define ARP_QUEUEING                    0
N#endif
N
N/**
N * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
N * updated with the source MAC and IP addresses supplied in the packet.
N * You may want to disable this if you do not trust LAN peers to have the
N * correct addresses, or as a limited approach to attempt to handle
N * spoofing. If disabled, lwIP will need to make a new ARP request if
N * the peer is not already in the ARP table, adding a little latency.
N * The peer *is* in the ARP table if it requested our address before.
N * Also notice that this slows down input processing of every IP packet!
N */
N#ifndef ETHARP_TRUST_IP_MAC
N#define ETHARP_TRUST_IP_MAC             0
N#endif
N
N/**
N * ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
N * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
N * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
N * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
N */
N#ifndef ETHARP_SUPPORT_VLAN
N#define ETHARP_SUPPORT_VLAN             0
N#endif
N
N/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
N * might be disabled
N */
N#ifndef LWIP_ETHERNET
N#define LWIP_ETHERNET                   (LWIP_ARP || PPPOE_SUPPORT)
N#endif
N
N/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
N * alignment of payload after that header. Since the header is 14 bytes long,
N * without this padding e.g. addresses in the IP header will not be aligned
N * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
N */
N#ifndef ETH_PAD_SIZE
S#define ETH_PAD_SIZE                    0
N#endif
N
N/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
N * entries (using etharp_add_static_entry/etharp_remove_static_entry).
N */
N#ifndef ETHARP_SUPPORT_STATIC_ENTRIES
N#define ETHARP_SUPPORT_STATIC_ENTRIES   0
N#endif
N
N
N/*
N   --------------------------------
N   ---------- IP options ----------
N   --------------------------------
N*/
N/**
N * IP_FORWARD==1: Enables the ability to forward IP packets across network
N * interfaces. If you are going to run lwIP on a device with only one network
N * interface, define this to 0.
N */
N#ifndef IP_FORWARD
S#define IP_FORWARD                      0
N#endif
N
N/**
N * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
N *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
N *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
N */
N#ifndef IP_OPTIONS_ALLOWED
N#define IP_OPTIONS_ALLOWED              1
N#endif
N
N/**
N * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
N * this option does not affect outgoing packet sizes, which can be controlled
N * via IP_FRAG.
N */
N#ifndef IP_REASSEMBLY
N#define IP_REASSEMBLY                   1
N#endif
N
N/**
N * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
N * that this option does not affect incoming packet sizes, which can be
N * controlled via IP_REASSEMBLY.
N */
N#ifndef IP_FRAG
N#define IP_FRAG                         1
N#endif
N
N/**
N * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
N * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
N * in this time, the whole packet is discarded.
N */
N#ifndef IP_REASS_MAXAGE
N#define IP_REASS_MAXAGE                 3
N#endif
N
N/**
N * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
N * Since the received pbufs are enqueued, be sure to configure
N * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
N * packets even if the maximum amount of fragments is enqueued for reassembly!
N */
N#ifndef IP_REASS_MAX_PBUFS
N#define IP_REASS_MAX_PBUFS              10
N#endif
N
N/**
N * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
N * fragmentation. Otherwise pbufs are allocated and reference the original
N * packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
N * new PBUF_RAM pbufs are used for fragments).
N * ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
N */
N#ifndef IP_FRAG_USES_STATIC_BUF
N#define IP_FRAG_USES_STATIC_BUF         0
N#endif
N
N/**
N * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
N * (requires IP_FRAG_USES_STATIC_BUF==1)
N */
N#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
X#if 0 && !0L
S#define IP_FRAG_MAX_MTU                 1500
N#endif
N
N/**
N * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
N */
N#ifndef IP_DEFAULT_TTL
N#define IP_DEFAULT_TTL                  255
N#endif
N
N/**
N * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
N * filter per pcb on udp and raw send operations. To enable broadcast filter
N * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
N */
N#ifndef IP_SOF_BROADCAST
N#define IP_SOF_BROADCAST                0
N#endif
N
N/**
N * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
N * filter on recv operations.
N */
N#ifndef IP_SOF_BROADCAST_RECV
N#define IP_SOF_BROADCAST_RECV           0
N#endif
N
N/*
N   ----------------------------------
N   ---------- ICMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
N * Be careful, disable that make your product non-compliant to RFC1122
N */
N#ifndef LWIP_ICMP
N#define LWIP_ICMP                       1
N#endif
N
N/**
N * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
N */
N#ifndef ICMP_TTL
S#define ICMP_TTL                       (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
N */
N#ifndef LWIP_BROADCAST_PING
N#define LWIP_BROADCAST_PING             0
N#endif
N
N/**
N * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
N */
N#ifndef LWIP_MULTICAST_PING
N#define LWIP_MULTICAST_PING             0
N#endif
N
N/*
N   ---------------------------------
N   ---------- RAW options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef LWIP_RAW
N#define LWIP_RAW                        1
N#endif
N
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef RAW_TTL
N#define RAW_TTL                        (IP_DEFAULT_TTL)
N#endif
N
N/*
N   ----------------------------------
N   ---------- DHCP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_DHCP==1: Enable DHCP module.
N */
N#ifndef LWIP_DHCP
S#define LWIP_DHCP                       1
N#endif
N
N/**
N * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
N */
N#ifndef DHCP_DOES_ARP_CHECK
N#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
N#endif
N
N/*
N   ------------------------------------
N   ---------- AUTOIP options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_AUTOIP==1: Enable AUTOIP module.
N */
N#ifndef LWIP_AUTOIP
N#define LWIP_AUTOIP                     0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
N * the same interface at the same time.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP
N#define LWIP_DHCP_AUTOIP_COOP           0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
N * that should be sent before falling back on AUTOIP. This can be set
N * as low as 1 to get an AutoIP address very quickly, but you should
N * be prepared to handle a changing IP address when DHCP overrides
N * AutoIP.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
N#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
N#endif
N
N/*
N   ----------------------------------
N   ---------- SNMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
N * transport.
N */
N#ifndef LWIP_SNMP
N#define LWIP_SNMP                       0
N#endif
N
N/**
N * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
N * allow. At least one request buffer is required.
N * Does not have to be changed unless external MIBs answer request asynchronously
N */
N#ifndef SNMP_CONCURRENT_REQUESTS
N#define SNMP_CONCURRENT_REQUESTS        1
N#endif
N
N/**
N * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
N * destination is required
N */
N#ifndef SNMP_TRAP_DESTINATIONS
N#define SNMP_TRAP_DESTINATIONS          1
N#endif
N
N/**
N * SNMP_PRIVATE_MIB: 
N * When using a private MIB, you have to create a file 'private_mib.h' that contains
N * a 'struct mib_array_node mib_private' which contains your MIB.
N */
N#ifndef SNMP_PRIVATE_MIB
N#define SNMP_PRIVATE_MIB                0
N#endif
N
N/**
N * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
N * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
N * Unsafe requests are disabled by default!
N */
N#ifndef SNMP_SAFE_REQUESTS
N#define SNMP_SAFE_REQUESTS              1
N#endif
N
N/**
N * The maximum length of strings used. This affects the size of
N * MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_OCTET_STRING_LEN
N#define SNMP_MAX_OCTET_STRING_LEN       127
N#endif
N
N/**
N * The maximum depth of the SNMP tree.
N * With private MIBs enabled, this depends on your MIB!
N * This affects the size of MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_TREE_DEPTH
N#define SNMP_MAX_TREE_DEPTH             15
N#endif
N
N/**
N * The size of the MEMP_SNMP_VALUE elements, normally calculated from
N * SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
N */
N#ifndef SNMP_MAX_VALUE_SIZE
N#define SNMP_MAX_VALUE_SIZE             LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN)+1, sizeof(s32_t)*(SNMP_MAX_TREE_DEPTH))
N#endif
N
N/*
N   ----------------------------------
N   ---------- IGMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_IGMP==1: Turn on IGMP module. 
N */
N#ifndef LWIP_IGMP
N#define LWIP_IGMP                       1
N#endif
N
N/*
N   ----------------------------------
N   ---------- DNS options -----------
N   ----------------------------------
N*/
N/**
N * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
N * transport.
N */
N#ifndef LWIP_DNS
N#define LWIP_DNS                        1
N#endif
N
N/** DNS maximum number of entries to maintain locally. */
N#ifndef DNS_TABLE_SIZE
N#define DNS_TABLE_SIZE                  4
N#endif
N
N/** DNS maximum host name length supported in the name table. */
N#ifndef DNS_MAX_NAME_LENGTH
N#define DNS_MAX_NAME_LENGTH             256
N#endif
N
N/** The maximum of DNS servers */
N#ifndef DNS_MAX_SERVERS
N#define DNS_MAX_SERVERS                 2
N#endif
N
N/** DNS do a name checking between the query and the response. */
N#ifndef DNS_DOES_NAME_CHECK
N#define DNS_DOES_NAME_CHECK             1
N#endif
N
N/** DNS message max. size. Default value is RFC compliant. */
N#ifndef DNS_MSG_SIZE
N#define DNS_MSG_SIZE                    512
N#endif
N
N/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
N *  you have to define
N *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
N *  (an array of structs name/address, where address is an u32_t in network
N *  byte order).
N *
N *  Instead, you can also use an external function:
N *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
N *  that returns the IP address or INADDR_NONE if not found.
N */
N#define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}}
N#ifndef DNS_LOCAL_HOSTLIST
N#define DNS_LOCAL_HOSTLIST              1
N#endif /* DNS_LOCAL_HOSTLIST */
N
N/** If this is turned on, the local host-list can be dynamically changed
N *  at runtime. */
N#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
N#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   1
N#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N
N/*
N   ---------------------------------
N   ---------- UDP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_UDP==1: Turn on UDP.
N */
N#ifndef LWIP_UDP
S#define LWIP_UDP                        1
N#endif
N
N/**
N * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
N */
N#ifndef LWIP_UDPLITE
N#define LWIP_UDPLITE                    0
N#endif
N
N/**
N * UDP_TTL: Default Time-To-Live value.
N */
N#ifndef UDP_TTL
S#define UDP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
N */
N#ifndef LWIP_NETBUF_RECVINFO
N#define LWIP_NETBUF_RECVINFO            0
N#endif
N
N/*
N   ---------------------------------
N   ---------- TCP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_TCP==1: Turn on TCP.
N */
N#ifndef LWIP_TCP
S#define LWIP_TCP                        1
N#endif
N
N/**
N * TCP_TTL: Default Time-To-Live value.
N */
N#ifndef TCP_TTL
S#define TCP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * TCP_WND: The size of a TCP window.  This must be at least 
N * (2 * TCP_MSS) for things to work well
N */
N#ifndef TCP_WND
S#define TCP_WND                         (4 * TCP_MSS)
N#endif 
N
N/**
N * TCP_MAXRTX: Maximum number of retransmissions of data segments.
N */
N#ifndef TCP_MAXRTX
S#define TCP_MAXRTX                      12
N#endif
N
N/**
N * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
N */
N#ifndef TCP_SYNMAXRTX
S#define TCP_SYNMAXRTX                   6
N#endif
N
N/**
N * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
N * Define to 0 if your device is low on memory.
N */
N#ifndef TCP_QUEUE_OOSEQ
S#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
N#endif
N
N/**
N * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
N * you might want to increase this.)
N * For the receive side, this MSS is advertised to the remote side
N * when opening a connection. For the transmit size, this MSS sets
N * an upper limit on the MSS advertised by the remote host.
N */
N#ifndef TCP_MSS
S#define TCP_MSS                         536
N#endif
N
N/**
N * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
N * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
N * reflects the available reassembly buffer size at the remote host) and the
N * largest size permitted by the IP layer" (RFC 1122)
N * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
N * netif used for a connection and limits the MSS if it would be too big otherwise.
N */
N#ifndef TCP_CALCULATE_EFF_SEND_MSS
N#define TCP_CALCULATE_EFF_SEND_MSS      1
N#endif
N
N
N/**
N * TCP_SND_BUF: TCP sender buffer space (bytes). 
N */
N#ifndef TCP_SND_BUF
S#define TCP_SND_BUF                     256
N#endif
N
N/**
N * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
N */
N#ifndef TCP_SND_QUEUELEN
S#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
N#endif
N
N/**
N * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
N * TCP_SND_BUF. It is the amount of space which must be available in the
N * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
N */
N#ifndef TCP_SNDLOWAT
N#define TCP_SNDLOWAT                     LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)//((TCP_SND_BUF)/2)
N#endif
N
N/**
N * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be grater
N * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
N * this number, select returns writable (combined with TCP_SNDLOWAT).
N */
N#ifndef TCP_SNDQUEUELOWAT
N#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)// ((TCP_SND_QUEUELEN)/2)
N#endif
N
N/**
N * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
N */
N#ifndef TCP_LISTEN_BACKLOG
N#define TCP_LISTEN_BACKLOG              0
N#endif
N
N/**
N * The maximum allowed backlog for TCP listen netconns.
N * This backlog is used unless another is explicitly specified.
N * 0xff is the maximum (u8_t).
N */
N#ifndef TCP_DEFAULT_LISTEN_BACKLOG
N#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
N#endif
N
N/**
N * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
N * allocate ahead of time in an attempt to create shorter pbuf chains
N * for transmission. The meaningful range is 0 to TCP_MSS. Some
N * suggested values are:
N *
N * 0:         Disable oversized allocation. Each tcp_write() allocates a new
N              pbuf (old behaviour).
N * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
N *            scatter-gather DMA requires aligned fragments.
N * 128:       Limit the pbuf/memory overhead to 20%.
N * TCP_MSS:   Try to create unfragmented TCP packets.
N * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
N */
N#ifndef TCP_OVERSIZE
N#define TCP_OVERSIZE                    TCP_MSS
N#endif
N
N/**
N * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
N */
N#ifndef LWIP_TCP_TIMESTAMPS
N#define LWIP_TCP_TIMESTAMPS             0
N#endif
N
N/**
N * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
N * explicit window update
N */
N#ifndef TCP_WND_UPDATE_THRESHOLD
N#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
N#endif
N
N/**
N * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
N *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
N *         events (accept, sent, etc) that happen in the system.
N *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
N *         for the event.
N */
N#ifndef LWIP_EVENT_API
N#define LWIP_EVENT_API                  0
N#define LWIP_CALLBACK_API               1
N#else 
S#define LWIP_EVENT_API                  1
S#define LWIP_CALLBACK_API               0
N#endif
N
N
N/*
N   ----------------------------------
N   ---------- Pbuf options ----------
N   ----------------------------------
N*/
N/**
N * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
N * link level header. The default is 14, the standard value for
N * Ethernet.
N */
N#ifndef PBUF_LINK_HLEN
S#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
N#endif
N
N/**
N * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
N * designed to accomodate single full size TCP frame in one pbuf, including
N * TCP_MSS, IP header, and link header.
N */
N#ifndef PBUF_POOL_BUFSIZE
S#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Network Interfaces options ----------
N   ------------------------------------------------
N*/
N/**
N * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
N * field.
N */
N#ifndef LWIP_NETIF_HOSTNAME
N#define LWIP_NETIF_HOSTNAME             0
N#endif
N
N/**
N * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
N */
N#ifndef LWIP_NETIF_API
N#define LWIP_NETIF_API                  0
N#endif
N
N/**
N * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
N * changes its up/down status (i.e., due to DHCP IP acquistion)
N */
N#ifndef LWIP_NETIF_STATUS_CALLBACK
S#define LWIP_NETIF_STATUS_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#ifndef LWIP_NETIF_LINK_CALLBACK
N#define LWIP_NETIF_LINK_CALLBACK        0
N#endif
N
N/**
N * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
N * indices) in struct netif. TCP and UDP can make use of this to prevent
N * scanning the ARP table for every sent packet. While this is faster for big
N * ARP tables or many concurrent connections, it might be counterproductive
N * if you have a tiny ARP table or if there never are concurrent connections.
N */
N#ifndef LWIP_NETIF_HWADDRHINT
N#define LWIP_NETIF_HWADDRHINT           0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
N * address equal to the netif IP address, looping them back up the stack.
N */
N#ifndef LWIP_NETIF_LOOPBACK
N#define LWIP_NETIF_LOOPBACK             0
N#endif
N
N/**
N * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
N * sending for each netif (0 = disabled)
N */
N#ifndef LWIP_LOOPBACK_MAX_PBUFS
N#define LWIP_LOOPBACK_MAX_PBUFS         0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
N * the system, as netifs must change how they behave depending on this setting
N * for the LWIP_NETIF_LOOPBACK option to work.
N * Setting this is needed to avoid reentering non-reentrant functions like
N * tcp_input().
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
N *       multithreaded environment like tcpip.c. In this case, netif->input()
N *       is called directly.
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
N *       The packets are put on a list and netif_poll() must be called in
N *       the main application loop.
N */
N#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
N#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
N#endif
N
N/**
N * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
N * to be sent into one single pbuf. This is for compatibility with DMA-enabled
N * MACs that do not support scatter-gather.
N * Beware that this might involve CPU-memcpy before transmitting that would not
N * be needed without this flag! Use this only if you need to!
N *
N * @todo: TCP and IP-frag do not work with this, yet:
N */
N#ifndef LWIP_NETIF_TX_SINGLE_PBUF
N#define LWIP_NETIF_TX_SINGLE_PBUF             0
N#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
N
N/*
N   ------------------------------------
N   ---------- LOOPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
N */
N#ifndef LWIP_HAVE_LOOPIF
N#define LWIP_HAVE_LOOPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- SLIPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
N */
N#ifndef LWIP_HAVE_SLIPIF
N#define LWIP_HAVE_SLIPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- Thread options ----------
N   ------------------------------------
N*/
N/**
N * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
N */
N#ifndef TCPIP_THREAD_NAME
S#define TCPIP_THREAD_NAME              "tcpip_thread"
N#endif
N
N/**
N * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_STACKSIZE
S#define TCPIP_THREAD_STACKSIZE          0
N#endif
N
N/**
N * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_PRIO
S#define TCPIP_THREAD_PRIO               3
N#endif
N
N/**
N * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when tcpip_init is called.
N */
N#ifndef TCPIP_MBOX_SIZE
S#define TCPIP_MBOX_SIZE                 0
N#endif
N
N/**
N * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
N */
N#ifndef SLIPIF_THREAD_NAME
S#define SLIPIF_THREAD_NAME             "slipif_loop"
N#endif
N
N/**
N * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_STACKSIZE
S#define SLIPIF_THREAD_STACKSIZE         0
N#endif
N
N/**
N * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_PRIO
S#define SLIPIF_THREAD_PRIO              1
N#endif
N
N/**
N * PPP_THREAD_NAME: The name assigned to the pppInputThread.
N */
N#ifndef PPP_THREAD_NAME
S#define PPP_THREAD_NAME                "pppInputThread"
N#endif
N
N/**
N * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_STACKSIZE
S#define PPP_THREAD_STACKSIZE            0
N#endif
N
N/**
N * PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_PRIO
S#define PPP_THREAD_PRIO                 1
N#endif
N
N/**
N * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
N */
N#ifndef DEFAULT_THREAD_NAME
S#define DEFAULT_THREAD_NAME            "lwIP"
N#endif
N
N/**
N * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_STACKSIZE
S#define DEFAULT_THREAD_STACKSIZE        0
N#endif
N
N/**
N * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_PRIO
S#define DEFAULT_THREAD_PRIO             1
N#endif
N
N/**
N * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_RAW_RECVMBOX_SIZE
S#define DEFAULT_RAW_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_UDP_RECVMBOX_SIZE
S#define DEFAULT_UDP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_TCP_RECVMBOX_SIZE
S#define DEFAULT_TCP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when the acceptmbox is created.
N */
N#ifndef DEFAULT_ACCEPTMBOX_SIZE
S#define DEFAULT_ACCEPTMBOX_SIZE         0
N#endif
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING
N#define LWIP_TCPIP_CORE_LOCKING         0
N#endif
N
N/**
N * LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING_INPUT
N#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
N#endif
N
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#ifndef LWIP_NETCONN
N#define LWIP_NETCONN                    1
N#endif
N
N/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
N * timers running in tcpip_thread from another thread.
N */
N#ifndef LWIP_TCPIP_TIMEOUT
N#define LWIP_TCPIP_TIMEOUT              1
N#endif
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#ifndef LWIP_SOCKET
N#define LWIP_SOCKET                     1
N#endif
N
N/**
N * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
N * (only used if you use sockets.c)
N */
N#ifndef LWIP_COMPAT_SOCKETS
N#define LWIP_COMPAT_SOCKETS             1
N#endif
N
N/**
N * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
N * Disable this option if you use a POSIX operating system that uses the same
N * names (read, write & close). (only used if you use sockets.c)
N */
N#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
N#define LWIP_POSIX_SOCKETS_IO_NAMES     1
N#endif
N
N/**
N * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
N * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
N * in seconds. (does not require sockets.c, and will affect tcp.c)
N */
N#ifndef LWIP_TCP_KEEPALIVE
N#define LWIP_TCP_KEEPALIVE              1
N#endif
N
N/**
N * LWIP_SO_RCVTIMEO==1: Enable SO_RCVTIMEO processing.
N */
N#ifndef LWIP_SO_RCVTIMEO
N#define LWIP_SO_RCVTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
N */
N#ifndef LWIP_SO_RCVBUF
N#define LWIP_SO_RCVBUF                  0
N#endif
N
N/**
N * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
N */
N#ifndef RECV_BUFSIZE_DEFAULT
N#define RECV_BUFSIZE_DEFAULT            INT_MAX
N#endif
N
N/**
N * SO_REUSE==1: Enable SO_REUSEADDR option.
N */
N#ifndef SO_REUSE
N#define SO_REUSE                        1
N#endif
N
N/**
N * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
N * to all local matches if SO_REUSEADDR is turned on.
N * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
N */
N#ifndef SO_REUSE_RXTOALL
N#define SO_REUSE_RXTOALL                0
N#endif
N
N/*
N   ----------------------------------------
N   ---------- Statistics options ----------
N   ----------------------------------------
N*/
N/**
N * LWIP_STATS==1: Enable statistics collection in lwip_stats.
N */
N#ifndef LWIP_STATS
S#define LWIP_STATS                      1
N#endif
N
N#if LWIP_STATS
X#if 1
N
N/**
N * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
N */
N#ifndef LWIP_STATS_DISPLAY
S#define LWIP_STATS_DISPLAY              0
N#endif
N
N/**
N * LINK_STATS==1: Enable link stats.
N */
N#ifndef LINK_STATS
S#define LINK_STATS                      1
N#endif
N
N/**
N * ETHARP_STATS==1: Enable etharp stats.
N */
N#ifndef ETHARP_STATS
N#define ETHARP_STATS                    (LWIP_ARP)
N#endif
N
N/**
N * IP_STATS==1: Enable IP stats.
N */
N#ifndef IP_STATS
S#define IP_STATS                        1
N#endif
N
N/**
N * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
N * on if using either frag or reass.
N */
N#ifndef IPFRAG_STATS
N#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
N#endif
N
N/**
N * ICMP_STATS==1: Enable ICMP stats.
N */
N#ifndef ICMP_STATS
S#define ICMP_STATS                      1
N#endif
N
N/**
N * IGMP_STATS==1: Enable IGMP stats.
N */
N#ifndef IGMP_STATS
N#define IGMP_STATS                      (LWIP_IGMP)
N#endif
N
N/**
N * UDP_STATS==1: Enable UDP stats. Default is on if
N * UDP enabled, otherwise off.
N */
N#ifndef UDP_STATS
S#define UDP_STATS                       (LWIP_UDP)
N#endif
N
N/**
N * TCP_STATS==1: Enable TCP stats. Default is on if TCP
N * enabled, otherwise off.
N */
N#ifndef TCP_STATS
S#define TCP_STATS                       (LWIP_TCP)
N#endif
N
N/**
N * MEM_STATS==1: Enable mem.c stats.
N */
N#ifndef MEM_STATS
S#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
N#endif
N
N/**
N * MEMP_STATS==1: Enable memp.c pool stats.
N */
N#ifndef MEMP_STATS
S#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
N#endif
N
N/**
N * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
N */
N#ifndef SYS_STATS
S#define SYS_STATS                       (NO_SYS == 0)
N#endif
N
N#else
S
S#define LINK_STATS                      0
S#define IP_STATS                        0
S#define IPFRAG_STATS                    0
S#define ICMP_STATS                      0
S#define IGMP_STATS                      0
S#define UDP_STATS                       0
S#define TCP_STATS                       0
S#define MEM_STATS                       0
S#define MEMP_STATS                      0
S#define SYS_STATS                       0
S#define LWIP_STATS_DISPLAY              0
S
N#endif /* LWIP_STATS */
N
N/*
N   ---------------------------------
N   ---------- PPP options ----------
N   ---------------------------------
N*/
N/**
N * PPP_SUPPORT==1: Enable PPP.
N */
N#ifndef PPP_SUPPORT
N#define PPP_SUPPORT                     0
N#endif
N
N/**
N * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
N */
N#ifndef PPPOE_SUPPORT
N#define PPPOE_SUPPORT                   0
N#endif
N
N/**
N * PPPOS_SUPPORT==1: Enable PPP Over Serial
N */
N#ifndef PPPOS_SUPPORT
N#define PPPOS_SUPPORT                   PPP_SUPPORT
N#endif
N
N#if PPP_SUPPORT
X#if 0
S
S/**
S * NUM_PPP: Max PPP sessions.
S */
S#ifndef NUM_PPP
S#define NUM_PPP                         1
S#endif
S
S/**
S * PAP_SUPPORT==1: Support PAP.
S */
S#ifndef PAP_SUPPORT
S#define PAP_SUPPORT                     0
S#endif
S
S/**
S * CHAP_SUPPORT==1: Support CHAP.
S */
S#ifndef CHAP_SUPPORT
S#define CHAP_SUPPORT                    0
S#endif
S
S/**
S * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef MSCHAP_SUPPORT
S#define MSCHAP_SUPPORT                  0
S#endif
S
S/**
S * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CBCP_SUPPORT
S#define CBCP_SUPPORT                    0
S#endif
S
S/**
S * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CCP_SUPPORT
S#define CCP_SUPPORT                     0
S#endif
S
S/**
S * VJ_SUPPORT==1: Support VJ header compression.
S */
S#ifndef VJ_SUPPORT
S#define VJ_SUPPORT                      0
S#endif
S
S/**
S * MD5_SUPPORT==1: Support MD5 (see also CHAP).
S */
S#ifndef MD5_SUPPORT
S#define MD5_SUPPORT                     0
S#endif
S
S/*
S * Timeouts
S */
S#ifndef FSM_DEFTIMEOUT
S#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
S#endif
S
S#ifndef FSM_DEFMAXTERMREQS
S#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXCONFREQS
S#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXNAKLOOPS
S#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
S#endif
S
S#ifndef UPAP_DEFTIMEOUT
S#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
S#endif
S
S#ifndef UPAP_DEFREQTIME
S#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
S#endif
S
S#ifndef CHAP_DEFTIMEOUT
S#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
S#endif
S
S#ifndef CHAP_DEFTRANSMITS
S#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
S#endif
S
S/* Interval in seconds between keepalive echo requests, 0 to disable. */
S#ifndef LCP_ECHOINTERVAL
S#define LCP_ECHOINTERVAL                0
S#endif
S
S/* Number of unanswered echo requests before failure. */
S#ifndef LCP_MAXECHOFAILS
S#define LCP_MAXECHOFAILS                3
S#endif
S
S/* Max Xmit idle time (in jiffies) before resend flag char. */
S#ifndef PPP_MAXIDLEFLAG
S#define PPP_MAXIDLEFLAG                 100
S#endif
S
S/*
S * Packet sizes
S *
S * Note - lcp shouldn't be allowed to negotiate stuff outside these
S *    limits.  See lcp.h in the pppd directory.
S * (XXX - these constants should simply be shared by lcp.c instead
S *    of living in lcp.h)
S */
S#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
S#ifndef PPP_MAXMTU
S/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
S#define PPP_MAXMTU                      1500 /* Largest MTU we allow */
S#endif
S#define PPP_MINMTU                      64
S#define PPP_MRU                         1500     /* default MRU = max length of info field */
S#define PPP_MAXMRU                      1500     /* Largest MRU we allow */
S#ifndef PPP_DEFMRU
S#define PPP_DEFMRU                      296             /* Try for this */
S#endif
S#define PPP_MINMRU                      128             /* No MRUs below this */
S
S#ifndef MAXNAMELEN
S#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
S#endif
S#ifndef MAXSECRETLEN
S#define MAXSECRETLEN                    256     /* max length of password or secret */
S#endif
S
N#endif /* PPP_SUPPORT */
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N/**
N * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
N */
N#ifndef CHECKSUM_GEN_IP
N#define CHECKSUM_GEN_IP                 1
N#endif
N 
N/**
N * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
N */
N#ifndef CHECKSUM_GEN_UDP
N#define CHECKSUM_GEN_UDP                1
N#endif
N 
N/**
N * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
N */
N#ifndef CHECKSUM_GEN_TCP
N#define CHECKSUM_GEN_TCP                1
N#endif
N 
N/**
N * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
N */
N#ifndef CHECKSUM_CHECK_IP
N#define CHECKSUM_CHECK_IP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
N */
N#ifndef CHECKSUM_CHECK_UDP
N#define CHECKSUM_CHECK_UDP              1
N#endif
N
N/**
N * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
N */
N#ifndef CHECKSUM_CHECK_TCP
N#define CHECKSUM_CHECK_TCP              1
N#endif
N
N/**
N * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
N * application buffers to pbufs.
N */
N#ifndef LWIP_CHECKSUM_ON_COPY
N#define LWIP_CHECKSUM_ON_COPY           0
N#endif
N
N/*
N   ---------------------------------------
N   ---------- Debugging options ----------
N   ---------------------------------------
N*/
N/**
N * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
N * compared against this value. If it is smaller, then debugging
N * messages are written.
N */
N#ifndef LWIP_DBG_MIN_LEVEL
N#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
N#endif
N
N/**
N * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
N * debug messages of certain types.
N */
N#ifndef LWIP_DBG_TYPES_ON
N#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
N#endif
N
N/**
N * ETHARP_DEBUG: Enable debugging in etharp.c.
N */
N#ifndef ETHARP_DEBUG
S#define ETHARP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * NETIF_DEBUG: Enable debugging in netif.c.
N */
N#ifndef NETIF_DEBUG
S#define NETIF_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PBUF_DEBUG: Enable debugging in pbuf.c.
N */
N#ifndef PBUF_DEBUG
S#define PBUF_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * API_LIB_DEBUG: Enable debugging in api_lib.c.
N */
N#ifndef API_LIB_DEBUG
S#define API_LIB_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * API_MSG_DEBUG: Enable debugging in api_msg.c.
N */
N#ifndef API_MSG_DEBUG
S#define API_MSG_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * SOCKETS_DEBUG: Enable debugging in sockets.c.
N */
N#ifndef SOCKETS_DEBUG
S#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * ICMP_DEBUG: Enable debugging in icmp.c.
N */
N#ifndef ICMP_DEBUG
S#define ICMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IGMP_DEBUG: Enable debugging in igmp.c.
N */
N#ifndef IGMP_DEBUG
N#define IGMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * INET_DEBUG: Enable debugging in inet.c.
N */
N#ifndef INET_DEBUG
S#define INET_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IP_DEBUG: Enable debugging for IP.
N */
N#ifndef IP_DEBUG
S#define IP_DEBUG                        LWIP_DBG_OFF
N#endif
N
N/**
N * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
N */
N#ifndef IP_REASS_DEBUG
S#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * RAW_DEBUG: Enable debugging in raw.c.
N */
N#ifndef RAW_DEBUG
S#define RAW_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEM_DEBUG: Enable debugging in mem.c.
N */
N#ifndef MEM_DEBUG
S#define MEM_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEMP_DEBUG: Enable debugging in memp.c.
N */
N#ifndef MEMP_DEBUG
S#define MEMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * SYS_DEBUG: Enable debugging in sys.c.
N */
N#ifndef SYS_DEBUG
S#define SYS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TIMERS_DEBUG: Enable debugging in timers.c.
N */
N#ifndef TIMERS_DEBUG
N#define TIMERS_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_DEBUG: Enable debugging for TCP.
N */
N#ifndef TCP_DEBUG
S#define TCP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
N */
N#ifndef TCP_INPUT_DEBUG
S#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
N */
N#ifndef TCP_FR_DEBUG
S#define TCP_FR_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
N * timeout.
N */
N#ifndef TCP_RTO_DEBUG
S#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
N */
N#ifndef TCP_CWND_DEBUG
S#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
N */
N#ifndef TCP_WND_DEBUG
S#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
N */
N#ifndef TCP_OUTPUT_DEBUG
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
N */
N#ifndef TCP_RST_DEBUG
S#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
N */
N#ifndef TCP_QLEN_DEBUG
S#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * UDP_DEBUG: Enable debugging in UDP.
N */
N#ifndef UDP_DEBUG
S#define UDP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCPIP_DEBUG: Enable debugging in tcpip.c.
N */
N#ifndef TCPIP_DEBUG
S#define TCPIP_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PPP_DEBUG: Enable debugging for PPP.
N */
N#ifndef PPP_DEBUG
N#define PPP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * SLIP_DEBUG: Enable debugging in slipif.c.
N */
N#ifndef SLIP_DEBUG
N#define SLIP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * DHCP_DEBUG: Enable debugging in dhcp.c.
N */
N#ifndef DHCP_DEBUG
N#define DHCP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * AUTOIP_DEBUG: Enable debugging in autoip.c.
N */
N#ifndef AUTOIP_DEBUG
N#define AUTOIP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
N */
N#ifndef SNMP_MSG_DEBUG
N#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
N */
N#ifndef SNMP_MIB_DEBUG
N#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * DNS_DEBUG: Enable debugging for DNS.
N */
N#ifndef DNS_DEBUG
N#define DNS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N#endif /* __LWIP_OPT_H__ */
L 38 "..\sdk\1.50\include\lwip/sockets.h" 2
N
N#if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
X#if 1  
N
N#include <stddef.h> /* for size_t */
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
Ntypedef signed int ptrdiff_t;
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* others (e.g. <stdio.h>) also define */
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32)
X    #if 0L
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 42 "..\sdk\1.50\include\lwip/sockets.h" 2
N
N#include "lwip/ip_addr.h"
L 1 "..\sdk\1.50\include\lwip/ip_addr.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_IP_ADDR_H__
N#define __LWIP_IP_ADDR_H__
N
N#include "lwip/opt.h"
N#include "lwip/def.h"
L 1 "..\sdk\1.50\include\lwip/def.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEF_H__
N#define __LWIP_DEF_H__
N
N/* arch.h might define NULL already */
N#include "lwip/arch.h"
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
N#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
N
N#ifndef NULL
S#define NULL ((void *)0)
N#endif
N
N/** Get the absolute difference between 2 u32_t values (correcting overflows)
N * 'a' is expected to be 'higher' (without overflow) than 'b'. */
N#define LWIP_U32_DIFF(a, b) (((a) >= (b)) ? ((a) - (b)) : (((a) + ((b) ^ 0xFFFFFFFF) + 1))) 
N
N/* Endianess-optimized shifting of two u8_t to create one u16_t */
N#if BYTE_ORDER == LITTLE_ENDIAN
X#if 1234 == 1234
N#define LWIP_MAKE_U16(a, b) ((a << 8) | b)
N#else
S#define LWIP_MAKE_U16(a, b) ((b << 8) | a)
N#endif 
N
N#ifndef LWIP_PLATFORM_BYTESWAP
N#define LWIP_PLATFORM_BYTESWAP 0
N#endif
N
N#ifndef LWIP_PREFIX_BYTEORDER_FUNCS
N/* workaround for naming collisions on some platforms */
N
N#ifdef htons
S#undef htons
N#endif /* htons */
N#ifdef htonl
S#undef htonl
N#endif /* htonl */
N#ifdef ntohs
S#undef ntohs
N#endif /* ntohs */
N#ifdef ntohl
S#undef ntohl
N#endif /* ntohl */
N
N#define htons(x) lwip_htons(x)
N#define ntohs(x) lwip_ntohs(x)
N#define htonl(x) lwip_htonl(x)
N#define ntohl(x) lwip_ntohl(x)
N#endif /* LWIP_PREFIX_BYTEORDER_FUNCS */
N
N#if BYTE_ORDER == BIG_ENDIAN
X#if 1234 == 4321
S#define lwip_htons(x) (x)
S#define lwip_ntohs(x) (x)
S#define lwip_htonl(x) (x)
S#define lwip_ntohl(x) (x)
S#define PP_HTONS(x) (x)
S#define PP_NTOHS(x) (x)
S#define PP_HTONL(x) (x)
S#define PP_NTOHL(x) (x)
N#else /* BYTE_ORDER != BIG_ENDIAN */
N#if LWIP_PLATFORM_BYTESWAP
X#if 0
S#define lwip_htons(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_ntohs(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_htonl(x) LWIP_PLATFORM_HTONL(x)
S#define lwip_ntohl(x) LWIP_PLATFORM_HTONL(x)
N#else /* LWIP_PLATFORM_BYTESWAP */
Nu16_t lwip_htons(u16_t x);
Nu16_t lwip_ntohs(u16_t x);
Nu32_t lwip_htonl(u32_t x);
Nu32_t lwip_ntohl(u32_t x);
N#endif /* LWIP_PLATFORM_BYTESWAP */
N
N/* These macros should be calculated by the preprocessor and are used
N   with compile-time constants only (so that there is no little-endian
N   overhead at runtime). */
N#define PP_HTONS(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
N#define PP_NTOHS(x) PP_HTONS(x)
N#define PP_HTONL(x) ((((x) & 0xff) << 24) | \
N                     (((x) & 0xff00) << 8) | \
N                     (((x) & 0xff0000UL) >> 8) | \
N                     (((x) & 0xff000000UL) >> 24))
X#define PP_HTONL(x) ((((x) & 0xff) << 24) |                      (((x) & 0xff00) << 8) |                      (((x) & 0xff0000UL) >> 8) |                      (((x) & 0xff000000UL) >> 24))
N#define PP_NTOHL(x) PP_HTONL(x)
N
N#endif /* BYTE_ORDER == BIG_ENDIAN */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_DEF_H__ */
N
L 37 "..\sdk\1.50\include\lwip/ip_addr.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* This is the aligned version of ip_addr_t,
N   used as local variable, on the stack, etc. */
Nstruct ip_addr {
N  u32_t addr;
N};
N
N/* This is the packed version of ip_addr_t,
N   used in network headers that are itself packed */
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X
Nstruct ip_addr_packed {
N  PACK_STRUCT_FIELD(u32_t addr);
X  u32_t addr;
N} PACK_STRUCT_STRUCT;
X} __attribute__ ((packed));
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N/** ip_addr_t uses a struct for convenience only, so that the same defines can
N * operate both on ip_addr_t as well as on ip_addr_p_t. */
Ntypedef struct ip_addr ip_addr_t;
Ntypedef struct ip_addr_packed ip_addr_p_t;
N
N/*
N * struct ipaddr2 is used in the definition of the ARP packet format in
N * order to support compilers that don't have structure packing.
N */
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X
Nstruct ip_addr2 {
N  PACK_STRUCT_FIELD(u16_t addrw[2]);
X  u16_t addrw[2];
N} PACK_STRUCT_STRUCT;
X} __attribute__ ((packed));
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N/* Forward declaration to not include netif.h */
Nstruct netif;
N
Nextern const ip_addr_t ip_addr_any;
Nextern const ip_addr_t ip_addr_broadcast;
N
N/** IP_ADDR_ can be used as a fixed IP address
N *  for the wildcard and the broadcast address
N */
N#define IP_ADDR_ANY         ((ip_addr_t *)&ip_addr_any)
N#define IP_ADDR_BROADCAST   ((ip_addr_t *)&ip_addr_broadcast)
N
N/** 255.255.255.255 */
N#define IPADDR_NONE         ((u32_t)0xffffffffUL)
N/** 127.0.0.1 */
N#define IPADDR_LOOPBACK     ((u32_t)0x7f000001UL)
N/** 0.0.0.0 */
N#define IPADDR_ANY          ((u32_t)0x00000000UL)
N/** 255.255.255.255 */
N#define IPADDR_BROADCAST    ((u32_t)0xffffffffUL)
N
N/* Definitions of the bits in an Internet address integer.
N
N   On subnets, host and network parts are found according to
N   the subnet mask, not these masks.  */
N#define IP_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
N#define IP_CLASSA_NET       0xff000000
N#define IP_CLASSA_NSHIFT    24
N#define IP_CLASSA_HOST      (0xffffffff & ~IP_CLASSA_NET)
N#define IP_CLASSA_MAX       128
N
N#define IP_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
N#define IP_CLASSB_NET       0xffff0000
N#define IP_CLASSB_NSHIFT    16
N#define IP_CLASSB_HOST      (0xffffffff & ~IP_CLASSB_NET)
N#define IP_CLASSB_MAX       65536
N
N#define IP_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
N#define IP_CLASSC_NET       0xffffff00
N#define IP_CLASSC_NSHIFT    8
N#define IP_CLASSC_HOST      (0xffffffff & ~IP_CLASSC_NET)
N
N#define IP_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
N#define IP_CLASSD_NET       0xf0000000          /* These ones aren't really */
N#define IP_CLASSD_NSHIFT    28                  /*   net and host fields, but */
N#define IP_CLASSD_HOST      0x0fffffff          /*   routing needn't know. */
N#define IP_MULTICAST(a)     IP_CLASSD(a)
N
N#define IP_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
N#define IP_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
N
N#define IP_LOOPBACKNET      127                 /* official! */
N
N
N#if BYTE_ORDER == BIG_ENDIAN
X#if 1234 == 4321
S/** Set an IP address given by the four byte-parts */
S#define IP4_ADDR(ipaddr, a,b,c,d) \
S        (ipaddr)->addr = ((u32_t)((a) & 0xff) << 24) | \
S                         ((u32_t)((b) & 0xff) << 16) | \
S                         ((u32_t)((c) & 0xff) << 8)  | \
S                          (u32_t)((d) & 0xff)
X#define IP4_ADDR(ipaddr, a,b,c,d)         (ipaddr)->addr = ((u32_t)((a) & 0xff) << 24) |                          ((u32_t)((b) & 0xff) << 16) |                          ((u32_t)((c) & 0xff) << 8)  |                           (u32_t)((d) & 0xff)
N#else
N/** Set an IP address given by the four byte-parts.
N    Little-endian version that prevents the use of htonl. */
N#define IP4_ADDR(ipaddr, a,b,c,d) \
N        (ipaddr)->addr = ((u32_t)((d) & 0xff) << 24) | \
N                         ((u32_t)((c) & 0xff) << 16) | \
N                         ((u32_t)((b) & 0xff) << 8)  | \
N                          (u32_t)((a) & 0xff)
X#define IP4_ADDR(ipaddr, a,b,c,d)         (ipaddr)->addr = ((u32_t)((d) & 0xff) << 24) |                          ((u32_t)((c) & 0xff) << 16) |                          ((u32_t)((b) & 0xff) << 8)  |                           (u32_t)((a) & 0xff)
N#endif
N
N/** MEMCPY-like copying of IP addresses where addresses are known to be
N * 16-bit-aligned if the port is correctly configured (so a port could define
N * this to copying 2 u16_t's) - no NULL-pointer-checking needed. */
N#ifndef IPADDR2_COPY
N#define IPADDR2_COPY(dest, src) SMEMCPY(dest, src, sizeof(ip_addr_t))
N#endif
N
N/** Copy IP address - faster than ip_addr_set: no NULL check */
N#define ip_addr_copy(dest, src) ((dest).addr = (src).addr)
N/** Safely copy one IP address to another (src may be NULL) */
N#define ip_addr_set(dest, src) ((dest)->addr = \
N                                    ((src) == NULL ? 0 : \
N                                    (src)->addr))
X#define ip_addr_set(dest, src) ((dest)->addr =                                     ((src) == NULL ? 0 :                                     (src)->addr))
N/** Set complete address to zero */
N#define ip_addr_set_zero(ipaddr)      ((ipaddr)->addr = 0)
N/** Set address to IPADDR_ANY (no need for htonl()) */
N#define ip_addr_set_any(ipaddr)       ((ipaddr)->addr = IPADDR_ANY)
N/** Set address to loopback address */
N#define ip_addr_set_loopback(ipaddr)  ((ipaddr)->addr = PP_HTONL(IPADDR_LOOPBACK))
N/** Safely copy one IP address to another and change byte order
N * from host- to network-order. */
N#define ip_addr_set_hton(dest, src) ((dest)->addr = \
N                               ((src) == NULL ? 0:\
N                               htonl((src)->addr)))
X#define ip_addr_set_hton(dest, src) ((dest)->addr =                                ((src) == NULL ? 0:                               htonl((src)->addr)))
N/** IPv4 only: set the IP address given as an u32_t */
N#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
N/** IPv4 only: get the IP address as an u32_t */
N#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
N
N/** Get the network address by combining host address with netmask */
N#define ip_addr_get_network(target, host, netmask) ((target)->addr = ((host)->addr) & ((netmask)->addr))
N
N/**
N * Determine if two address are on the same network.
N *
N * @arg addr1 IP address 1
N * @arg addr2 IP address 2
N * @arg mask network identifier mask
N * @return !0 if the network identifiers of both address match
N */
N#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
N                                              (mask)->addr) == \
N                                             ((addr2)->addr & \
N                                              (mask)->addr))
X#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr &                                               (mask)->addr) ==                                              ((addr2)->addr &                                               (mask)->addr))
N#define ip_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
N
N#define ip_addr_isany(addr1) ((addr1) == NULL || (addr1)->addr == IPADDR_ANY)
N
N#define ip_addr_isbroadcast(ipaddr, netif) ip4_addr_isbroadcast((ipaddr)->addr, (netif))
Nu8_t ip4_addr_isbroadcast(u32_t addr, const struct netif *netif);
N
N#define ip_addr_netmask_valid(netmask) ip4_addr_netmask_valid((netmask)->addr)
Nu8_t ip4_addr_netmask_valid(u32_t netmask);
N
N#define ip_addr_ismulticast(addr1) (((addr1)->addr & PP_HTONL(0xf0000000UL)) == PP_HTONL(0xe0000000UL))
N
N#define ip_addr_islinklocal(addr1) (((addr1)->addr & PP_HTONL(0xffff0000UL)) == PP_HTONL(0xa9fe0000UL))
N
N#define ip_addr_debug_print(debug, ipaddr) \
N  LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,             \
N                      ipaddr != NULL ? ip4_addr1_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr2_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr3_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr4_16(ipaddr) : 0))
X#define ip_addr_debug_print(debug, ipaddr)   LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,                                   ipaddr != NULL ? ip4_addr1_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr2_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr3_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr4_16(ipaddr) : 0))
N
N/* Get one byte from the 4-byte address */
N#define ip4_addr1(ipaddr) (((u8_t*)(ipaddr))[0])
N#define ip4_addr2(ipaddr) (((u8_t*)(ipaddr))[1])
N#define ip4_addr3(ipaddr) (((u8_t*)(ipaddr))[2])
N#define ip4_addr4(ipaddr) (((u8_t*)(ipaddr))[3])
N/* These are cast to u16_t, with the intent that they are often arguments
N * to printf using the U16_F format from cc.h. */
N#define ip4_addr1_16(ipaddr) ((u16_t)ip4_addr1(ipaddr))
N#define ip4_addr2_16(ipaddr) ((u16_t)ip4_addr2(ipaddr))
N#define ip4_addr3_16(ipaddr) ((u16_t)ip4_addr3(ipaddr))
N#define ip4_addr4_16(ipaddr) ((u16_t)ip4_addr4(ipaddr))
N
N/** For backwards compatibility */
N#define ip_ntoa(ipaddr)  ipaddr_ntoa(ipaddr)
N
Nu32_t ipaddr_addr(const char *cp);
Nint ipaddr_aton(const char *cp, ip_addr_t *addr);
N/** returns ptr to static buffer; not reentrant! */
Nchar *ipaddr_ntoa(const ip_addr_t *addr);
Nchar *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_IP_ADDR_H__ */
L 44 "..\sdk\1.50\include\lwip/sockets.h" 2
N#include "lwip/inet.h"
L 1 "..\sdk\1.50\include\lwip/inet.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_INET_H__
N#define __LWIP_INET_H__
N
N#include "lwip/opt.h"
N#include "lwip/def.h"
N#include "lwip/ip_addr.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** For compatibility with BSD code */
Nstruct in_addr {
N  u32_t s_addr;
N};
N
N/** 255.255.255.255 */
N#define INADDR_NONE         IPADDR_NONE
N/** 127.0.0.1 */
N#define INADDR_LOOPBACK     IPADDR_LOOPBACK
N/** 0.0.0.0 */
N#define INADDR_ANY          IPADDR_ANY
N/** 255.255.255.255 */
N#define INADDR_BROADCAST    IPADDR_BROADCAST
N
N/* Definitions of the bits in an Internet address integer.
N
N   On subnets, host and network parts are found according to
N   the subnet mask, not these masks.  */
N#define IN_CLASSA(a)        IP_CLASSA(a)
N#define IN_CLASSA_NET       IP_CLASSA_NET
N#define IN_CLASSA_NSHIFT    IP_CLASSA_NSHIFT
N#define IN_CLASSA_HOST      IP_CLASSA_HOST
N#define IN_CLASSA_MAX       IP_CLASSA_MAX
N
N#define IN_CLASSB(b)        IP_CLASSB(b)
N#define IN_CLASSB_NET       IP_CLASSB_NET
N#define IN_CLASSB_NSHIFT    IP_CLASSB_NSHIFT
N#define IN_CLASSB_HOST      IP_CLASSB_HOST
N#define IN_CLASSB_MAX       IP_CLASSB_MAX
N
N#define IN_CLASSC(c)        IP_CLASSC(c)
N#define IN_CLASSC_NET       IP_CLASSC_NET
N#define IN_CLASSC_NSHIFT    IP_CLASSC_NSHIFT
N#define IN_CLASSC_HOST      IP_CLASSC_HOST
N#define IN_CLASSC_MAX       IP_CLASSC_MAX
N
N#define IN_CLASSD(d)        IP_CLASSD(d)
N#define IN_CLASSD_NET       IP_CLASSD_NET     /* These ones aren't really */
N#define IN_CLASSD_NSHIFT    IP_CLASSD_NSHIFT  /*   net and host fields, but */
N#define IN_CLASSD_HOST      IP_CLASSD_HOST    /*   routing needn't know. */
N#define IN_CLASSD_MAX       IP_CLASSD_MAX
N
N#define IN_MULTICAST(a)     IP_MULTICAST(a)
N
N#define IN_EXPERIMENTAL(a)  IP_EXPERIMENTAL(a)
N#define IN_BADCLASS(a)      IP_BADCLASS(a)
N
N#define IN_LOOPBACKNET      IP_LOOPBACKNET
N
N#define inet_addr_from_ipaddr(target_inaddr, source_ipaddr) ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
N#define inet_addr_to_ipaddr(target_ipaddr, source_inaddr)   (ip4_addr_set_u32(target_ipaddr, (source_inaddr)->s_addr))
N/* ATTENTION: the next define only works because both s_addr and ip_addr_t are an u32_t effectively! */
N#define inet_addr_to_ipaddr_p(target_ipaddr_p, source_inaddr)   ((target_ipaddr_p) = (ip_addr_t*)&((source_inaddr)->s_addr))
N
N/* directly map this to the lwip internal functions */
N#define inet_addr(cp)         ipaddr_addr(cp)
N#define inet_aton(cp, addr)   ipaddr_aton(cp, (ip_addr_t*)addr)
N#define inet_ntoa(addr)       ipaddr_ntoa((ip_addr_t*)&(addr))
N#define inet_ntoa_r(addr, buf, buflen) ipaddr_ntoa_r((ip_addr_t*)&(addr), buf, buflen)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_INET_H__ */
L 45 "..\sdk\1.50\include\lwip/sockets.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* members are in network byte order */
Nstruct sockaddr_in {
N  u8_t sin_len;
N  u8_t sin_family;
N  u16_t sin_port;
N  struct in_addr sin_addr;
N  char sin_zero[8];
N};
N
Nstruct sockaddr {
N  u8_t sa_len;
N  u8_t sa_family;
N  char sa_data[14];
N};
N
N#ifndef socklen_t
N#  define socklen_t u32_t
N#endif
N
N/* Socket protocol types (TCP/UDP/RAW) */
N#define SOCK_STREAM     1
N#define SOCK_DGRAM      2
N#define SOCK_RAW        3
N
N/*
N * Option flags per-socket. These must match the SOF_ flags in ip.h (checked in init.c)
N */
N#define  SO_DEBUG       0x0001 /* Unimplemented: turn on debugging info recording */
N#define  SO_ACCEPTCONN  0x0002 /* socket has had listen() */
N#define  SO_REUSEADDR   0x0004 /* Allow local address reuse */
N#define  SO_KEEPALIVE   0x0008 /* keep connections alive */
N#define  SO_DONTROUTE   0x0010 /* Unimplemented: just use interface addresses */
N#define  SO_BROADCAST   0x0020 /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
N#define  SO_USELOOPBACK 0x0040 /* Unimplemented: bypass hardware when possible */
N#define  SO_LINGER      0x0080 /* linger on close if data present */
N#define  SO_OOBINLINE   0x0100 /* Unimplemented: leave received OOB data in line */
N#define  SO_REUSEPORT   0x0200 /* Unimplemented: allow local address & port reuse */
N
N#define SO_DONTLINGER   ((int)(~SO_LINGER))
N
N/*
N * Additional options, not kept in so_options.
N */
N#define SO_SNDBUF    0x1001    /* Unimplemented: send buffer size */
N#define SO_RCVBUF    0x1002    /* receive buffer size */
N#define SO_SNDLOWAT  0x1003    /* Unimplemented: send low-water mark */
N#define SO_RCVLOWAT  0x1004    /* Unimplemented: receive low-water mark */
N#define SO_SNDTIMEO  0x1005    /* Unimplemented: send timeout */
N#define SO_RCVTIMEO  0x1006    /* receive timeout */
N#define SO_ERROR     0x1007    /* get error status and clear */
N#define SO_TYPE      0x1008    /* get socket type */
N#define SO_CONTIMEO  0x1009    /* Unimplemented: connect timeout */
N#define SO_NO_CHECK  0x100a    /* don't create UDP checksum */
N
N
N/*
N * Structure used for manipulating linger option.
N */
Nstruct linger {
N       int l_onoff;                /* option on/off */
N       int l_linger;               /* linger time */
N};
N
N/*
N * Level number for (get/set)sockopt() to apply to socket itself.
N */
N#define  SOL_SOCKET  0xfff    /* options for socket level */
N
N
N#define AF_UNSPEC       0
N#define AF_INET         2
N#define PF_INET         AF_INET
N#define PF_UNSPEC       AF_UNSPEC
N
N#define IPPROTO_IP      0
N#define IPPROTO_TCP     6
N#define IPPROTO_UDP     17
N#define IPPROTO_UDPLITE 136
N
N/* Flags we can use with send and recv. */
N#define MSG_PEEK       0x01    /* Peeks at an incoming message */
N#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
N#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
N#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
N#define MSG_MORE       0x10    /* Sender will send more */
N
N
N/*
N * Options for level IPPROTO_IP
N */
N#define IP_TOS             1
N#define IP_TTL             2
N
N#if LWIP_TCP
X#if 1
N/*
N * Options for level IPPROTO_TCP
N */
N#define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */
N#define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
N#define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */
N#define TCP_KEEPINTVL  0x04    /* set pcb->keep_intvl - Use seconds for get/setsockopt */
N#define TCP_KEEPCNT    0x05    /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
N#endif /* LWIP_TCP */
N
N#if LWIP_UDP && LWIP_UDPLITE
X#if 1 && 0
S/*
S * Options for level IPPROTO_UDPLITE
S */
S#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
S#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
N#endif /* LWIP_UDP && LWIP_UDPLITE*/
N
N
N#if LWIP_IGMP
X#if 1
N/*
N * Options and types for UDP multicast traffic handling
N */
N#define IP_ADD_MEMBERSHIP  3
N#define IP_DROP_MEMBERSHIP 4
N#define IP_MULTICAST_TTL   5
N#define IP_MULTICAST_IF    6
N#define IP_MULTICAST_LOOP  7
N
Ntypedef struct ip_mreq {
N    struct in_addr imr_multiaddr; /* IP multicast address of group */
N    struct in_addr imr_interface; /* local IP address of interface */
N} ip_mreq;
N#endif /* LWIP_IGMP */
N
N/*
N * The Type of Service provides an indication of the abstract
N * parameters of the quality of service desired.  These parameters are
N * to be used to guide the selection of the actual service parameters
N * when transmitting a datagram through a particular network.  Several
N * networks offer service precedence, which somehow treats high
N * precedence traffic as more important than other traffic (generally
N * by accepting only traffic above a certain precedence at time of high
N * load).  The major choice is a three way tradeoff between low-delay,
N * high-reliability, and high-throughput.
N * The use of the Delay, Throughput, and Reliability indications may
N * increase the cost (in some sense) of the service.  In many networks
N * better performance for one of these parameters is coupled with worse
N * performance on another.  Except for very unusual cases at most two
N * of these three indications should be set.
N */
N#define IPTOS_TOS_MASK          0x1E
N#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
N#define IPTOS_LOWDELAY          0x10
N#define IPTOS_THROUGHPUT        0x08
N#define IPTOS_RELIABILITY       0x04
N#define IPTOS_LOWCOST           0x02
N#define IPTOS_MINCOST           IPTOS_LOWCOST
N
N/*
N * The Network Control precedence designation is intended to be used
N * within a network only.  The actual use and control of that
N * designation is up to each network. The Internetwork Control
N * designation is intended for use by gateway control originators only.
N * If the actual use of these precedence designations is of concern to
N * a particular network, it is the responsibility of that network to
N * control the access to, and use of, those precedence designations.
N */
N#define IPTOS_PREC_MASK                 0xe0
N#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
N#define IPTOS_PREC_NETCONTROL           0xe0
N#define IPTOS_PREC_INTERNETCONTROL      0xc0
N#define IPTOS_PREC_CRITIC_ECP           0xa0
N#define IPTOS_PREC_FLASHOVERRIDE        0x80
N#define IPTOS_PREC_FLASH                0x60
N#define IPTOS_PREC_IMMEDIATE            0x40
N#define IPTOS_PREC_PRIORITY             0x20
N#define IPTOS_PREC_ROUTINE              0x00
N
N
N/*
N * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
N * lwip_ioctl only supports FIONREAD and FIONBIO, for now
N *
N * Ioctl's have the command encoded in the lower word,
N * and the size of any in or out parameters in the upper
N * word.  The high 2 bits of the upper word are used
N * to encode the in/out status of the parameter; for now
N * we restrict parameters to at most 128 bytes.
N */
N#if !defined(FIONREAD) || !defined(FIONBIO)
X#if !0L || !0L
N#define IOCPARM_MASK    0x7fU           /* parameters must be < 128 bytes */
N#define IOC_VOID        0x20000000UL    /* no parameters */
N#define IOC_OUT         0x40000000UL    /* copy out parameters */
N#define IOC_IN          0x80000000UL    /* copy in parameters */
N#define IOC_INOUT       (IOC_IN|IOC_OUT)
N                                        /* 0x20000000 distinguishes new &
N                                           old ioctl's */
N#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))
N
N#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
N
N#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
N#endif /* !defined(FIONREAD) || !defined(FIONBIO) */
N
N#ifndef FIONREAD
N#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
N#endif
N#ifndef FIONBIO
N#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
N#endif
N
N/* Socket I/O Controls: unimplemented */
N#ifndef SIOCSHIWAT
N#define SIOCSHIWAT  _IOW('s',  0, unsigned long)  /* set high watermark */
N#define SIOCGHIWAT  _IOR('s',  1, unsigned long)  /* get high watermark */
N#define SIOCSLOWAT  _IOW('s',  2, unsigned long)  /* set low watermark */
N#define SIOCGLOWAT  _IOR('s',  3, unsigned long)  /* get low watermark */
N#define SIOCATMARK  _IOR('s',  7, unsigned long)  /* at oob mark? */
N#endif
N
N/* commands for fnctl */
N#ifndef F_GETFL
N#define F_GETFL 3
N#endif
N#ifndef F_SETFL
N#define F_SETFL 4
N#endif
N
N/* File status flags and file access modes for fnctl,
N   these are bits in an int. */
N#ifndef O_NONBLOCK
N#define O_NONBLOCK  1 /* nonblocking I/O */
N#endif
N#ifndef O_NDELAY
N#define O_NDELAY    1 /* same as O_NONBLOCK, for compatibility */
N#endif
N
N#ifndef SHUT_RD
N  #define SHUT_RD   0
N  #define SHUT_WR   1
N  #define SHUT_RDWR 2
N#endif
N
N/* FD_SET used for lwip_select */
N#ifndef FD_SET
N  #undef  FD_SETSIZE
N  /* Make FD_SETSIZE match NUM_SOCKETS in socket.c */
N  #define FD_SETSIZE    24
N  #define FD_SET(n, p)  ((p)->fd_bits[(n)/8] |=  (1 << ((n) & 7)))
N  #define FD_CLR(n, p)  ((p)->fd_bits[(n)/8] &= ~(1 << ((n) & 7)))
N  #define FD_ISSET(n,p) ((p)->fd_bits[(n)/8] &   (1 << ((n) & 7)))
N  #define FD_ZERO(p)    memset((void*)(p),0,sizeof(*(p)))
N
N  typedef struct fd_set {
N          unsigned char fd_bits [(FD_SETSIZE+7)/8];
X          unsigned char fd_bits [(24+7)/8];
N        } fd_set;
N
N#endif /* FD_SET */
N
N/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
N * by your system, set this to 0 and include <sys/time.h> in cc.h */ 
N#ifndef LWIP_TIMEVAL_PRIVATE
N#define LWIP_TIMEVAL_PRIVATE 1
N#endif
N
N#if LWIP_TIMEVAL_PRIVATE
X#if 1
Nstruct timeval {
N  unsigned int    tv_sec;         /* seconds */
N  unsigned int    tv_usec;        /* and microseconds */
N};
N#endif /* LWIP_TIMEVAL_PRIVATE */
N
Nvoid lwip_socket_init(void);
N
Nint lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
Xint lwip_accept(int s, struct sockaddr *addr, u32_t *addrlen);
Nint lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
Xint lwip_bind(int s, const struct sockaddr *name, u32_t namelen);
Nint lwip_shutdown(int s, int how);
Nint lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen);
Xint lwip_getpeername (int s, struct sockaddr *name, u32_t *namelen);
Nint lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen);
Xint lwip_getsockname (int s, struct sockaddr *name, u32_t *namelen);
Nint lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen);
Xint lwip_getsockopt (int s, int level, int optname, void *optval, u32_t *optlen);
Nint lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen);
Xint lwip_setsockopt (int s, int level, int optname, const void *optval, u32_t optlen);
Nint lwip_close(int s);
Nint lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
Xint lwip_connect(int s, const struct sockaddr *name, u32_t namelen);
Nint lwip_listen(int s, int backlog);
Nint lwip_recv(int s, void *mem, size_t len, int flags);
Nint lwip_read(int s, void *mem, size_t len);
Nint lwip_recvfrom(int s, void *mem, size_t len, int flags,
N      struct sockaddr *from, socklen_t *fromlen);
X      struct sockaddr *from, u32_t *fromlen);
Nint lwip_send(int s, const void *dataptr, size_t size, int flags);
Nint lwip_sendto(int s, const void *dataptr, size_t size, int flags,
N    const struct sockaddr *to, socklen_t tolen);
X    const struct sockaddr *to, u32_t tolen);
Nint lwip_socket(int domain, int type, int protocol);
Nint lwip_write(int s, const void *dataptr, size_t size);
Nint lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
N                struct timeval *timeout);
Nint lwip_ioctl(int s, long cmd, void *argp);
Nint lwip_fcntl(int s, int cmd, int val);
N
Nint sock_send(int *s, char *ptr, int num, unsigned char block);
N
N#if LWIP_COMPAT_SOCKETS
X#if 1
N#define accept(a,b,c)         lwip_accept(a,b,c)
N#define bind(a,b,c)           lwip_bind(a,b,c)
N#define shutdown(a,b)         lwip_shutdown(a,b)
N#define closesocket(s)        lwip_close(s)
N#define connect(a,b,c)        lwip_connect(a,b,c)
N#define getsockname(a,b,c)    lwip_getsockname(a,b,c)
N#define getpeername(a,b,c)    lwip_getpeername(a,b,c)
N#define setsockopt(a,b,c,d,e) lwip_setsockopt(a,b,c,d,e)
N#define getsockopt(a,b,c,d,e) lwip_getsockopt(a,b,c,d,e)
N#define listen(a,b)           lwip_listen(a,b)
N#define recv(a,b,c,d)         lwip_recv(a,b,c,d)
N#define recvfrom(a,b,c,d,e,f) lwip_recvfrom(a,b,c,d,e,f)
N#define send(a,b,c,d)         lwip_send(a,b,c,d)
N#define sendto(a,b,c,d,e,f)   lwip_sendto(a,b,c,d,e,f)
N#define socket(a,b,c)         lwip_socket(a,b,c)
N#define select(a,b,c,d,e)     lwip_select(a,b,c,d,e)
N#define ioctlsocket(a,b,c)    lwip_ioctl(a,b,c)
N
N#if LWIP_POSIX_SOCKETS_IO_NAMES
X#if 1
N#define read(a,b,c)           lwip_read(a,b,c)
N#define write(a,b,c)          lwip_write(a,b,c)
N#define close(s)              lwip_close(s)
N#endif /* LWIP_POSIX_SOCKETS_IO_NAMES */
N
N//Jim add
N#if 1 //def CONFIG_USE_018_SDK_MSGQ
N
Nint hf_lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
Xint hf_lwip_accept(int s, struct sockaddr *addr, u32_t *addrlen);
Nint hf_lwip_recv(int s, void *mem, size_t len, int flags);
Nint hf_lwip_recvfrom(int s, void *mem, size_t len, int flags,
N      struct sockaddr *from, socklen_t *fromlen);
X      struct sockaddr *from, u32_t *fromlen);
Nint hf_lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
Xint hf_lwip_connect(int s, const struct sockaddr *name, u32_t namelen);
Nint hf_lwip_socket(int domain, int type, int protocol);
Nint hf_lwip_close(int s);
Nint hf_lwip_listen(int s, int backlog);
N#undef accept
N#undef connect
N#undef recvfrom
N#undef recv
N#undef socket
N#undef close
N#undef listen
N
N#define accept(a,b,c)         hf_lwip_accept(a,b,c)
N#define connect(a,b,c)       hf_lwip_connect(a,b,c)
N#define recvfrom(a,b,c,d,e,f) hf_lwip_recvfrom(a,b,c,d,e,f)
N#define recv(a,b,c,d)         hf_lwip_recv(a,b,c,d)
N#define socket(a,b,c)		hf_lwip_socket(a,b,c)
N#define close(s)              	hf_lwip_close(s)
N#define listen(a,b)           hf_lwip_listen(a,b)
N#endif
N
N#endif /* LWIP_COMPAT_SOCKETS */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LWIP_SOCKET */
N
N#endif /* __LWIP_SOCKETS_H__ */
L 18 "..\sdk\1.50\include\hfnet.h" 2
N#include "httpc/httpc.h"
L 1 "..\sdk\1.50\include\httpc/httpc.h" 1
N/*! \file httpc.h
N *  \brief HTTP Client Module
N *
N * The HTTP Client module implements the functionality to perform HTTP
N * operations like GET and POST on a remote web server. The HTTP client handles
N * chunked encoding making it transparent to the user. It also supports
N * persistent connections with the web server. Multiple HTTP requests can thus
N * be channelled through the same persistent connection with the server.
N *
N * \section httpc_usage Usage
N *
N * The typical HTTP Client usage scenario is as follows:
N *
N * -# Initiate a connection with the remote Web Server using the
N *    http_open_session() call.
N * -# Prepare the request with a call to http_prepare_req. The mandatory
N *    fields are filled depending on the members set in httpc_req_t. If some
N *    default fields are to be set, this is set by enabling the
N *    corresponding flag bits passed to http_prepare_req. If more custom
N *    headers are to be added please add them using the call add_header.
N * -# Send one or more HTTP requests to the server using the
N *    http_prepare_req and http_send_request pair together. . The \ref
N *    httpc_req_t structure should be populated with the desired fields for
N *    each call if changed
N * -# An optional call to http_get_response_hdr() can be made if the application
N *    wishes to determine certain characteristics of the HTTP response.
N * -# Mutiple calls to http_read_content() are made for reading the response of
N *    the remote Web Server.
N * -# Once all the HTTP requests have been made, the connection with the remote
N *    server is terminated using the http_close_session() call.
N *
N */
N
N/*
N *  Copyright 2008-2012, Marvell International Ltd.
N *  All Rights Reserved.
N */
N
N#ifndef _HTTPC_H_
N#define _HTTPC_H_
N#include <hferrno.h>
N#include <time.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\time.h" 1
N/* time.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.12 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                      */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * time.h declares two macros, four types and several functions for
N * manipulating time. Many functions deal with a calendar time that
N * represents the current date (according to the Gregorian
N * calendar) and time. Some functions deal with local time, which
N * is the calendar time expressed for some specific time zone, and
N * with Daylight Savings Time, which is a temporary change in the
N * algorithm for determining local time.
N */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __time_h
N#define __time_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N  #ifndef __TIME_DECLS
N  #define __TIME_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N    /* CLOCKS_PER_SEC: the number per second of the value returned by the
N     * clock function. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S  extern const int __aeabi_CLOCKS_PER_SEC;
S  #define CLOCKS_PER_SEC (__aeabi_CLOCKS_PER_SEC)
N#else
N  #ifdef __CLK_TCK
S    #define CLOCKS_PER_SEC  __CLK_TCK
N  #else
N    #define CLOCKS_PER_SEC  100
N  #endif
N#endif
N
N#ifndef __STRICT_ANSI__
N  #define CLK_TCK CLOCKS_PER_SEC
N#endif
N
Ntypedef unsigned int clock_t;    /* cpu time type */
Ntypedef unsigned int time_t;     /* date/time in unix secs past 1-Jan-70 */
N
N#pragma push
N#pragma anon_unions
N
Nstruct tm {
N    int tm_sec;   /* seconds after the minute, 0 to 60
N                     (0 - 60 allows for the occasional leap second) */
N    int tm_min;   /* minutes after the hour, 0 to 59 */
N    int tm_hour;  /* hours since midnight, 0 to 23 */
N    int tm_mday;  /* day of the month, 1 to 31 */
N    int tm_mon;   /* months since January, 0 to 11 */
N    int tm_year;  /* years since 1900 */
N    int tm_wday;  /* days since Sunday, 0 to 6 */
N    int tm_yday;  /* days since January 1, 0 to 365 */
N    int tm_isdst; /* Daylight Savings Time flag */
N    union {       /* ABI-required extra fields, in a variety of types */
N        struct {
N            int __extra_1, __extra_2;
N        };
N        struct {
N            long __extra_1_long, __extra_2_long;
N        };
N        struct {
N            char *__extra_1_cptr, *__extra_2_cptr;
N        };
N        struct {
N            void *__extra_1_vptr, *__extra_2_vptr;
N        };
N    };
N};
N
N#pragma pop
N
N   /* struct tm holds the components of a calendar time, called the broken-down
N    * time. The value of tm_isdst is positive if Daylight Savings Time is in
N    * effect, zero if Daylight Savings Time is not in effect, and negative if
N    * the information is not available.
N    */
N
Nextern _ARMABI clock_t clock(void);
Xextern __declspec(__nothrow) clock_t clock(void);
N   /* determines the processor time used.
N    * Returns: the implementation's best approximation to the processor time
N    *          used by the program since program invocation. The time in
N    *          seconds is the value returned divided by the value of the macro
N    *          CLK_TCK. The value (clock_t)-1 is returned if the processor time
N    *          used is not available.
N    */
Nextern _ARMABI double difftime(time_t /*time1*/, time_t /*time0*/);
Xextern __declspec(__nothrow) double difftime(time_t  , time_t  );
N   /*
N    * computes the difference between two calendar times: time1 - time0.
N    * Returns: the difference expressed in seconds as a double.
N    */
Nextern _ARMABI time_t mktime(struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) time_t mktime(struct tm *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the broken-down time, expressed as local time, in the structure
N    * pointed to by timeptr into a calendar time value with the same encoding
N    * as that of the values returned by the time function. The original values
N    * of the tm_wday and tm_yday components of the structure are ignored, and
N    * the original values of the other components are not restricted to the
N    * ranges indicated above. On successful completion, the values of the
N    * tm_wday and tm_yday structure components are set appropriately, and the
N    * other components are set to represent the specified calendar time, but
N    * with their values forced to the ranges indicated above; the final value
N    * of tm_mday is not set until tm_mon and tm_year are determined.
N    * Returns: the specified calendar time encoded as a value of type time_t.
N    *          If the calendar time cannot be represented, the function returns
N    *          the value (time_t)-1.
N    */
Nextern _ARMABI time_t time(time_t * /*timer*/);
Xextern __declspec(__nothrow) time_t time(time_t *  );
N   /*
N    * determines the current calendar time. The encoding of the value is
N    * unspecified.
N    * Returns: the implementations best approximation to the current calendar
N    *          time. The value (time_t)-1 is returned if the calendar time is
N    *          not available. If timer is not a null pointer, the return value
N    *          is also assigned to the object it points to.
N    */
N
Nextern _ARMABI char *asctime(const struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *asctime(const struct tm *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI char *_asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *_asctime_r(const struct tm *  ,
N                                char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *asctime_r(const struct tm *  ,
N                               char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the broken-down time in the structure pointed to by timeptr into
N    * a string in the form "Sun Sep 16 01:03:52 1973\n\0".
N    * Returns: a pointer to the string containing the date and time.
N    */
Nextern _ARMABI char *ctime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *ctime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer to local time in the form
N    * of a string. It is equivalent to asctime(localtime(timer));
N    * Returns: the pointer returned by the asctime function with that
N    *          broken-down time as argument.
N    */
Nextern _ARMABI struct tm *gmtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *gmtime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed as Greenwich Mean Time (GMT).
N    * Returns: a pointer to that object or a null pointer if GMT not available.
N    */
Nextern _ARMABI struct tm *localtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *localtime(const time_t *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI struct tm *_localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *_localtime_r(const time_t * __restrict  ,
N                                       struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI struct tm *localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *localtime_r(const time_t * __restrict  ,
N                                      struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed a local time.
N    * Returns: a pointer to that object.
N    */
Nextern _ARMABI size_t strftime(char * __restrict /*s*/, size_t /*maxsize*/,
Xextern __declspec(__nothrow) size_t strftime(char * __restrict  , size_t  ,
N                       const char * __restrict /*format*/,
N                       const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N   /*
N    * places characters into the array pointed to by s as controlled by the
N    * string pointed to by format. The format string consists of zero or more
N    * directives and ordinary characters. A directive consists of a % character
N    * followed by a character that determines the directive's behaviour. All
N    * ordinary characters (including the terminating null character) are copied
N    * unchanged into the array. No more than maxsize characters are placed into
N    * the array. Each directive is replaced by appropriate characters  as
N    * described in the following list. The appropriate characters are
N    * determined by the LC_TIME category of the current locale and by the
N    * values contained in the structure pointed to by timeptr.
N    * %a is replaced by the locale's abbreviated weekday name.
N    * %A is replaced by the locale's full weekday name.
N    * %b is replaced by the locale's abbreviated month name.
N    * %B is replaced by the locale's full month name.
N    * %c is replaced by the locale's appropriate date and time representation.
N    * %d is replaced by the day of the month as a decimal number (01-31).
N    * %H is replaced by the hour (24-hour clock) as a decimal number (00-23).
N    * %I is replaced by the hour (12-hour clock) as a decimal number (01-12).
N    * %j is replaced by the day of the year as a decimal number (001-366).
N    * %m is replaced by the month as a decimal number (01-12).
N    * %M is replaced by the minute as a decimal number (00-59).
N    * %p is replaced by the locale's equivalent of either AM or PM designations
N    *       associated with a 12-hour clock.
N    * %S is replaced by the second as a decimal number (00-61).
N    * %U is replaced by the week number of the year (Sunday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %w is replaced by the weekday as a decimal number (0(Sunday) - 6).
N    * %W is replaced by the week number of the year (Monday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %x is replaced by the locale's appropriate date representation.
N    * %X is replaced by the locale's appropriate time representation.
N    * %y is replaced by the year without century as a decimal number (00-99).
N    * %Y is replaced by the year with century as a decimal number.
N    * %Z is replaced by the timezone name or abbreviation, or by no characters
N    *       if no time zone is determinable.
N    * %% is replaced by %.
N    * If a directive is not one of the above, the behaviour is undefined.
N    * Returns: If the total number of resulting characters including the
N    *          terminating null character is not more than maxsize, the
N    *          strftime function returns the number of characters placed into
N    *          the array pointed to by s not including the terminating null
N    *          character. otherwise, zero is returned and the contents of the
N    *          array are indeterminate.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __TIME_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __TIME_NO_EXPORTS
S      using ::std::clock_t;
S      using ::std::time_t;
S      using ::std::tm;
S      using ::std::tm;
S      using ::std::clock;
S      using ::std::difftime;
S      using ::std::mktime;
S      using ::std::time;
S      using ::std::asctime;
S      using ::std::_asctime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::asctime_r;
S#endif
S      using ::std::ctime;
S      using ::std::gmtime;
S      using ::std::localtime;
S      using ::std::_localtime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::localtime_r;
S#endif
S      using ::std::strftime;
S      using ::std::size_t;
S    #endif /* __TIME_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of time.h */
N
L 43 "..\sdk\1.50\include\httpc/httpc.h" 2
N
N#ifdef CONFIG_ENABLE_TLS
S#include <wm-tls.h>
N#else
Ntypedef void tls_init_config_t;
N#endif /* CONFIG_ENABLE_TLS */
N
Ntypedef int http_session_t;
N
N/* Request methods */
Ntypedef enum {
N	HTTP_OPTIONS,		/* request to server for communication  options */
N	HTTP_GET,		/* retrieve information */
N	HTTP_HEAD,		/* get meta-info */
N	HTTP_POST,		/* request to accept new sub-ordinate of resource */
N	HTTP_PUT,		/* modify or create new resource referred to by URI */
N	HTTP_DELETE,		/* delete the resource */
N	HTTP_TRACE,		/* echo */
N	HTTP_CONNECT,		/* do we need this  ? */
N} http_method_t;
N
Ntypedef enum {
N	HTTP_VER_1_0,
N	HTTP_VER_1_1,
N} http_ver_t;
N
N
N/*
N * The OR of zero or more flags below is passed to the function
N * \ref http_prepare_req. If the a flag is passed the corresponding HTTP
N * header field is added to the HTTP header. The values added will be
N * default ones.
N */
Ntypedef enum {
N	HDR_ADD_DEFAULT_USER_AGENT	= 0x0001,
N	/* Note: This flag is not necessary to set up persistent
N	 * connections in HTTP 1.1. However, if you want the server to
N	 * respond with persistent connection timeout values you may need
N	 * to add this flag. These timeout values are used to find out how
N	 * long a persistent connection will be kept alive by the
N	 * server. */
N	HDR_ADD_CONN_KEEP_ALIVE		= 0x0002,
N	HDR_ADD_CONN_CLOSE		= 0x0004,
N	HDR_ADD_TYPE_CHUNKED            = 0x0008,
N} http_hdr_field_sel_t;
N
N
N#define STANDARD_HDR_FLAGS			\
N	 (HDR_ADD_DEFAULT_USER_AGENT)
X#define STANDARD_HDR_FLAGS				 (HDR_ADD_DEFAULT_USER_AGENT)
N
N/*
N * Note 1: A resource is a part of the string immediately after the
N * hostname[:portno] part of the URL. In the URL,
N * [http://]hostname[:portno][/path/to/resource], 
N * "/path/to/resource" part is called as a resource. It starts with the
N * character '/'.
N */
N/** The HTTP Client's Request structure
N *
N * \par
N * The application should fill up this structure and pass it to the
N * http_prepare_req() function while making an HTTP request. More name-value
N * fields can be added to HTTP header using http_add_header().
N */
Ntypedef struct {
N	/** The Type of HTTP Request */
N	http_method_t type;
N	/** The target resource for the HTTP Request. A complete URL is also
N	 * accepted.
N	 */
N	const char *resource;
N	/** The HTTP Protocol Version */
N	http_ver_t version;
N	const char *content;
N	/** The length of the data pointed to by \a content above. This is
N	 * don't-care if the content is set to NULL
N	 */
N	int content_len;
N} httpc_req_t;
N
Ntypedef struct {
N	const char *protocol;
N	http_ver_t version;
N	int status_code;
N	const char *reason_phrase;	/* verbose string describing status code */
N	const char *server;
N	time_t modify_time;	/* time when the resource was last modified */
N	const char *content_type;
N	const char *content_encoding;
N	bool keep_alive_ack;
N	int keep_alive_timeout;	/* Server timeout */
N	int keep_alive_max;	/* Max time for which a persistent
N				   connection will be open, irrespective of
N				   connection activity  */
N	bool chunked;
N	uint32_t content_length;	/* This will be 0 if chunked == TRUE */
N} http_resp_t;
N
Ntypedef struct {
N	char *name;
N	char *value;
N} http_header_pair_t;
N
Ntypedef struct {
N	const char *scheme;
N	const char *hostname;
N	unsigned portno;
N	const char *resource;
N} parsed_url_t;
N
N/** HTTPC Error Codes **/
N
Nenum wm_httpc_errno {
N	HF_E_HTTPC_ERRNO_START = MOD_ERROR_START(MOD_HTTPC),
X	HF_E_HTTPC_ERRNO_START = ((2 << 16) | 0),
N	/* TCP connection failed (maybe due to unreachable server) */
N	HF_E_HTTPC_TCP_CONNECT_FAIL,
N	/* HTTP File not found */
N	HF_E_HTTPC_FILE_NOT_FOUND,
N	/* HTTP Bad Request */
N	HF_E_HTTPC_BAD_REQUEST,
N	/* TLS not enabled */
N	HF_E_HTTPC_TLS_NOT_ENABLED,
N};
N
N
N/* Status codes */
N#define HTTP_RESP_INFORMATIONAL(x) (x >=100 && < 200)
N#define HTTP_RESP_SUCCESS(x) (x >= 200 && x < 300)
N#define HTTP_RESP_REDIR(x) (x >= 300 && x < 400)
N#define HTTP_RESP_CLIENT_ERR(x) (x >= 400 && x < 500)
N#define HTTP_RESP_SERVER_ERR(x) (x >= 500 && x < 600)
N
N/* 
N * These macros are not of any use to the HTTP client itself. They are used
N * by the users of the HTTP client. This list may be extended if required 
N */
N#define HTTP_OK 200
N#define HTTP_CREATED 201
N#define HTTP_ACCEPTED  202
N#define HTTP_FOUND 302
N#define HTTP_NOT_MODIFIED 304
N
N#define HTTP_BAD_REQUEST 400
N#define HTTP_NOT_AUTH 401
N#define HTTP_FORBIDDEN 403
N#define HTTP_NOT_FOUND 404
N
N/**
N * If the given URL has a scheme field, and it is https then the http
N * client will auto-switch to SSL mode, irrespective of the TLS_ENABLE
N * flag below.
N */
Ntypedef enum {
N	/** Pass this flag when you want the connection to be SSL based */
N	TLS_ENABLE = 0x01,
N} http_open_flags_t;
N
N/**
N * Start an HTTP session.
N *
N * @par
N * This function starts a new HTTP session. It will create a socket and
N * then connect to the server.
N *
N *  @param[in,out] handle Pointer to a handle for the session. Will be
N *  assigned by the callee.
N *  @param[in] hostname Host name or IP address.  The hostname should be in
N *  the format [http://]hostname[:portno][/path/to/resource]. The fields
N *  between the  square brackets above are optional. The part specifying
N *  the resource will be ignored. The resource detail is expected by the \a
N *  http_send_request API to be called later after calling current function.
N *  @param[in] flags This is OR of the flags mentioned in enum
N *  \ref http_open_flags_t. Please look at the declaration of the enum for
N *  more information.
N *  @param[in] cfg This is a pointer of the type
N *  \ref tls_init_config_t. This will be passed verbatim to the tls
N *  layer. Please look at the wm-tls.h for the structure members. \b If TLS
N *  (secure connection) is not needed please pass NULL.
N *  @param[in] retry_cnt On some systems with constrained network resources,
N *  only a limited sockets can be active at any given time. If the socket
N *  creation fails, http_open_session will wait for some time and try to create
N *  the socket again for retry_cnt number of times. If 0 is passed then it will
N *  try default number of times depending on the platform. 0 is the recommended
N *  option.
N *
N * @return WM_SUCCESS on success
N * @return -HF_E_INVAL if any of the arguments were invalid
N * @return -WM_FAIL if the function was unable to initiate an HTTP session with
N * the server.
N */
Nint http_open_session(http_session_t * handle, const char *hostname,
N		      int flags, const tls_init_config_t *cfg,
N		      int retry_cnt);
N
N#define hfhttp_open_session	http_open_session
N
N/**
N * Prepare the HTTP header.
N *
N * This function will prepare an HTTP request before sending out an HTTP
N * request using the function \ref http_send_request. Calling this function is
N * mandatory before calling \ref http_send_request.
N *
N * @pre \ref http_open_session
N *
N * @param[in] handle Handle returned from the call to \a http_open_session
N * @param[in] req Allocated and initialized \ref httpc_req_t structure.
N * @param[in] field_flags Bitwise OR of flags of enum \ref
N * http_hdr_field_sel_t as required by the caller.
N *
N * @note The field_flags parameter is a way to request the http client to
N * use default field values for standard fields. If the corresponding bits
N * are not set then the respective fields are not added. The user can add
N * any custom fields including the standard ones using the API
N * \ref http_add_header
N *
N * @return Standard hfsdk return codes.
N */
Nint http_prepare_req(http_session_t handle, const httpc_req_t *req,
N		     http_hdr_field_sel_t field_flags);
N
N#define hfhttp_prepare_req	http_prepare_req			 
N
N/**
N * Add custom http headers to the partial generated header.
N *
N * This function allows the caller to add custom headers to the partial
N * http header generated by earlier call to \ref http_prepare_req.
N *
N * @note This function is optional and needs to be called only if custom
N * headers (or standard headers with non-default values) are to be added.
N *
N * @pre \ref http_prepare_req
N *
N * @param[in] handle Handle returned from the call to \a http_open_session
N * @param[in] name The name of the field. e.g User-Agent or
N * If-Modified-Since
N * @param[in] value Value associated with the name given above.
N *
N * @return Standard hfsdk value.
N */
Nint http_add_header(http_session_t handle, const char *name,
N		const char *value);
N
N#define hfhttp_add_header	http_add_header
N/**
N * Perform an HTTP request. 
N *
N * @par
N * This function will peform an HTTP request.
N *
N * @note If this function fails and the caller decides to abandon this
N * session altogether it needs to call  http_close_session()
N * explicitly. Failure to do this will cause undefined behaviour.
N *
N * @pre \a http_prepare_req mandatory. \a http_add_header optional.
N *
N * @param[in] handle Handle returned from the call to \a http_open_session
N * @param[in] req The \httpc_req_t structure filled up with appropriate
N * parameters as sent earlier to \ref http_prepare_req
N *
N * @return WM_SUCCESS on success
N * @return -HF_E_IO if failed to send data to network
N * @return -HF_E_INVAL for an invalid arguments.
N */
Nint http_send_request(http_session_t handle, const httpc_req_t * req);
N
N#define hfhttp_send_request	http_send_request
N/**
N * Get the HTTP response header
N *
N * @par
N * This function parses the response header received from the server and
N * populates the \a http_resp_t structure and returns the pointer to this
N * structure. The structure \a http_resp_t is allocated by the callee.
N * 
N * @par
N * The caller is expected to analyse this information to find out the
N * result of the earlier request sent through http_send_request(). If the
N * earlier request was HTTP_GET then the caller will need to call
N * http_read_content() to read the data sent by the server.
N *
N * @note Calling this function is \b optional. If the caller does not want to
N * read/analyse the header and knows beforehand what to expect, s/he can
N * directly call http_read_content(). The function \a http_read_content
N * will internally read the HTTP response header. However, the function 
N * \a http_read_content will return an error if the HTTP status code
N * returned is not 200.  If you need to read content in cases where the
N * return status code is other than 200 you need to call \ref
N * http_get_response_hdr first.
N *
N * @note If this function fails and the caller decides to abandon this
N * session altogether it needs to call http_close_session()
N * explicitly. Failure to do this will cause undefined behaviour.
N * 
N * @pre \a http_send_request is called before this call.
N *
N * @param[in] handle Handle returned from the call to \a http_new_session
N * @param[in,out] resp Pointer to a pointer of type \a http_resp_t. The
N * structure will be allocted by the callee.
N *
N * @return WM_SUCCESS on success
N * @return -WM_FAIL on error
N */
Nint http_get_response_hdr(http_session_t handle, http_resp_t ** resp);
N
N#define hfhttp_get_response_hdr		http_get_response_hdr
N
N/**
N * Get a particular HTTP response header value.
N *
N * @par
N * This function parses the response header received from the server and
N * returns the value corresponding to a given name.
N *
N * @par
N * The caller is not expected to call \ref http_get_response_hdr before
N * this. However, calling \ref http_get_response_hdr is recommended so that
N * the user gets to know the exact status of the HTTP operation before he
N * tries to extract any field not present in structure \ref http_resp_t.
N *
N * @note Calling this function is \b optional. If the caller does not want to
N * read/analyse the header and knows beforehand what to expect, s/he can
N * directly call http_read_content(). The function \a http_read_content
N * will internally read the HTTP response header. However, the function
N * \a http_read_content will return an error if the HTTP status code
N * returned is not 200. If you need to read content in cases where the
N * return status code is other than 200 you need to call \ref
N * http_get_response_hdr or the current function first.
N *
N * @note If this function fails and the caller decides to abandon this
N * session altogether it needs to call http_close_session()
N * explicitly. Failure to do this will cause undefined behaviour.
N *
N * @pre \a http_send_request is called before this call. Calling \ref
N * http_get_response_hdr is \b not mandatory but recommended.
N *
N * @param[in] handle Handle returned from the call to \a http_new_session
N * @param[in] header_name The name of the field whose value you wish to
N * know
N * @param[in,out] value A pointer which will point to the value
N * corresponding to the name passed as second parameter.
N *
N * @return WM_SUCCESS on success
N * @return -WM_FAIL on error
N */
N
Nint http_get_response_hdr_value(http_session_t handle,
N				const char *header_name, char **value);
N				
N#define hfhttp_get_response_hdr_value	http_get_response_hdr_value				
N				
N/**
N * Get requested number of HTTP response header name-value pairs.
N *
N * @par
N * This function parses the response header received from the server and
N * returns requested number of HTTP response header name-value pairs.
N *
N * @par
N * The caller is not expected to call \ref http_get_response_hdr before
N * this. However, calling \ref http_get_response_hdr is recommended so that
N * the user gets to know the exact status of the HTTP operation before he
N * tries to extract any field not present in structure \ref http_resp_t.
N *
N * @note Calling this function is \b optional. If the caller does not want to
N * read/analyse the header and knows beforehand what to expect, s/he can
N * directly call http_read_content(). The function \a http_read_content
N * will internally read the HTTP response header. However, the function
N * \a http_read_content will return an error if the HTTP status code
N * returned is not 200. If you need to read content in cases where the
N * return status code is other than 200 you need to call \ref
N * http_get_response_hdr or the current function first.
N *
N * @note If this function fails and the caller decides to abandon this
N * session altogether it needs to call http_close_session()
N * explicitly. Failure to do this will cause undefined behaviour.
N *
N * @pre \a http_send_request is called before this call. Calling \ref
N * http_get_response_hdr is \b not mandatory but recommended.
N *
N * @param[in] handle Handle returned from the call to \a http_new_session
N * @param[in,out] arr A pointer that points to an array of the
N * structure to hold the response header name-value pairs.
N * This array needs to be pre-allocated and its pointer is to be passed,
N * this pointer shall point to the array of requested number of
N * response header name-value pairs.
N * @param[in,out] count An interger pointer that points to the number of
N * response header name-value pairs that the user wants.
N * This has to be passed by the user and it is later updated to the
N * actual number of response header name-value pairs that were filled
N * in the array mentioned above.
N * @return WM_SUCCESS on success
N * @return -WM_FAIL on error
N */
N
Nint http_get_response_hdr_all(http_session_t handle, http_header_pair_t *arr,
N			      int *count);
N#define hfhttp_get_response_hdr_all	http_get_response_hdr_all
N/**
N * Read data content from the stream.
N *
N *@par
N * This function will read the data sent by the server.
N * 
N * @par
N * The data transfer from the server to the client may be chunked. This
N * fact will be reported in the response structure \ref http_resp_t returned
N * in a previous call to http_get_response_hdr(). Notwithstanding this
N * information, chunked data handling is transparent to the
N * caller. Irrespective of the transfer type, this function should be called
N * repeatedly till the return value of the function is zero.
N *
N * @note If this function fails and the caller decides to abandon this
N * session altogether it needs to call http_close_session()
N * explicitly. Failure to do this will cause undefined behaviour.
N * 
N * @param[in] handle Handle returned from the call to http_new_session()
N * @param[in, out] buf Caller allocated buffer of size max_len
N * @param[in] Size of the buffer. The data read will be less than or equal
N * to this size, depending on the size of the resource.
N *
N * @return On success, the number of bytes read is returned. Return value
N * of zero is \a not an error case  and should be treated as a signal that
N * server is done with sending the data.
N * @return -WM_FAIL if this function is called again after the previous call
N * retuned 0 or for any other error.
N */
N
Nint http_read_content(http_session_t handle, void *buf, uint32_t max_len);
N
N#define hfhttp_read_content(_h,_b,_l)	http_read_content(_h,_b,_l)
N
N/**
N * Parse the given string into URL subcomponents.
N *
N * The hostname string syntax is:
N *[scheme://]hostname[:port][/path_to_resource?query_string#fragment_id]
N * The fields between the square brackets above are optional.
N *
N * @note <b>Buffer management</b>: To free the caller of the task of
N * allocating multiple buffers of magic size to store each of the
N * subcomponents we use the following strategy. This function takes a tmp
N * buffer, allocted (static or dynamic) by the caller to store the
N * subcomponents. The caller needs to allocate this buffer with size equal
N * to (strlen(URL) + 10). When this function returns, the pointers in the
N * parsed_url structure will point to appropriate address in this
N * buffer. The caller may free this buffer after usage of the
N * sub-components is complete. Freeing before that will cause undefined behavior.
N *
N * @param[in] URL Pointer to the string containing the URL. This function
N * will not modify this argument.
N * @param[in] tmp_buf A buffer where the strings will be stored after
N * parsing. Needs to be allocated by the caller and should be of size
N * atleast 10 greater than size of the URL string passed as first
N * argument.
N * @param[in] tmp_buf_len Size of the caller allocated, temporary buffer
N * sent as second argument. 
N * @param[in, out] Pointer to an allocated structure. The member pointers
N * will point to the appropriate address in the temporary buffer holding
N * the NULL terminated string corresponding to the subcomponent.
N *
N */
Nint http_parse_URL(const char *URL, char *tmp_buf, int tmp_buf_len,
N		   parsed_url_t * parsed_url);
N
N#define hfhttp_parse_URL(_url,_b,_bl,_purl)		http_parse_URL(_url,_b,_bl,_purl)
N		   
N/**
N * HTTP lowlevel read
N *
N * This API is present to serve clients which want to handle the
N * HTTP stream directly. This is useful for handling websockets for e.g.
N *
N * @warning This is not for general users of HTTP client API. Normal HTTP
N * transactions do not need this API.
N *
N * @note Once this API used no other API from the HTTP API set, except \a
N * http_close_session, can be used. This is because once this API is used
N * the HTTP client loses track of the stream and only the caller using the
N * API can know the state of the stream.
N *
N * @param[in] handle Handle returned from the call to http_new_session()
N * @param[in, out] buf Pointer to an allocated buffer of size equal to or
N * more than the value of the third parameter maxlen
N * @param[in] maxlen The maximum number of bytes to be read from the
N * network. Note that the actual read bytes can be less than this.
N *
N * @return Number of bytes read. -HF_E_INVAL is returned in case of invalid
N * parameters. Standard libc error codes are returned in case when there
N * other problems.
N */
N
Nint http_lowlevel_read(http_session_t handle, void *buf, unsigned maxlen);
N
N#define hfhttp_lowlevel_read(_h,_b,_ml)	http_lowlevel_read(_h,_b,_ml)
N
N/**
N * HTTP lowlevel write
N *
N * This API is present to serve clients which want to handle the
N * HTTP stream directly. This is useful for handling websockets for e.g.
N *
N * @warning This is not for general users of HTTP client API. Normal HTTP
N * transactions do not need this API.
N *
N * @note Once this API used no other API from the HTTP API set, except \a
N * http_close_session, can be used. This is because once this API is used
N * the HTTP client loses track of the stream and only the caller using the
N * API can know the state of the stream.
N *
N * @param[in] handle Handle returned from the call to http_new_session()
N * @param[in, out] buf Pointer to a buffer which has the data to be written
N * out.
N * @param[in] maxlen The number of bytes to be written to the
N * network.
N *
N * @return Number of bytes written. -HF_E_INVAL is returned in case of
N * invalid parameters. Standard libc error codes are returned in case when
N * there other problems.
N */
N
Nint http_lowlevel_write(http_session_t  handle, const void *buf, unsigned len);
N
N#define hfhttp_lowlevel_write(_h,_b,_l)	http_lowlevel_write(_h,_b,_l)
N
N/**
N * HTTP write chunked
N *
N * This API is used for chunked transfer encoding
N *
N * @note To end the chunked data transfer, this function should be called with
N * len=0, buf may be NULL
N *
N * @param[in] handle Handle retrieved from the call to http_open_session
N * @param[in] data Pointer to the buffer to be posted
N * @param[in] len The number of bytes to be posted
N * @return WM_SUCCESS is returned on success. -HF_E_INVAL is returned in case
N * of invalid parameters. -WM_FAIL is returned if session is invalid.
N * Standard libc error codes are returned when there are other problems.
N */
N
Nint httpc_write_chunked(http_session_t handle, const char *data, int len);
N#define hfhttpc_write_chunked(_h,_d,_l)	httpc_write_chunked(_h,_d,_l)
N
N/**
N * Close the session.
N *
N * @par
N * This function will close the session represented by the given
N * handle. The socket associated with this session will be closed and thus
N * the TCP connection with the server will be terminated. No requests on
N * this same session will succeed after this function is called.
N *
N * @note <b>The response structure \ref http_resp_t returned earlier from
N *  http_get_response_hdr() will be invalid after this call.</b>
N *
N * @param[in] handle Handle returned from the previous call to
N * http_new_session(). The handle will be set to NULL by the callee thus
N * effectively blocking futher requests on the same session handle.
N *
N */
Nvoid http_close_session(http_session_t * handle);
N
N#define hfhttp_close_session(_h)	http_close_session(_h)
N
N#endif /* _HTTPC_H_ */
L 19 "..\sdk\1.50\include\hfnet.h" 2
N
N#define ASSIS_PORT 	48899
N#define HTTP_API_BUF_SIZE	1400
N
Ntypedef enum
N{
N	HFNET_SOCKETA_DATA_READY=0,
N	HFNET_SOCKETA_CONNECTED=1,
N	HFNET_SOCKETA_DISCONNECTED,
N	HFNET_SOCKETB_DATA_READY,
N	HFNET_SOCKETB_CONNECTED,
N	HFNET_SOCKETB_DISCONNECTED,
N	HFNET_UART0_DATA_READY,
N	HFNET_UART1_DATA_READY,
N	HFNET_ASSIS_DATA_READY
N}hfnet_event_id_t;
N
Ntypedef struct _hfnet_socketa_client
N{
N	int fd;
N	struct sockaddr_in addr;
N}hfnet_socketa_client_t,*phfnet_socketa_client_t;
N
Ntypedef int (*hfnet_callback_t)( uint32_t event,void *data,uint32_t len,uint32_t buf_len);
N
Ntypedef int (*hfhttpd_nvset_callback_t)( char * cfg_name,int name_len,char* value,int val_len);
N
Ntypedef int (*hfhttpd_nvget_callback_t)( char *cfg_name,int name_len,char *value,int val_len);
N
Ntypedef int (*hfhttpd_url_callback_t)(char *url, char *rsp);
N
Ntypedef int(*hfhttpd_process_cmd_func_t)(const char *name,void *ctx);
N
Nvoid HSF_API hfnet_httpd_set_get_nvram_callback(hfhttpd_nvset_callback_t p_set,hfhttpd_nvget_callback_t p_get);
Xvoid  hfnet_httpd_set_get_nvram_callback(hfhttpd_nvset_callback_t p_set,hfhttpd_nvget_callback_t p_get);
N
Nint HSF_API hfhttpd_url_callback_register(hfhttpd_url_callback_t callback, int flag);
Xint  hfhttpd_url_callback_register(hfhttpd_url_callback_t callback, int flag);
N
Nint HSF_API hfhttpd_url_callback_cancel(void);
Xint  hfhttpd_url_callback_cancel(void);
N
Nint HSF_API hfhttpd_send_data(char *data, int len);
Xint  hfhttpd_send_data(char *data, int len);
N
N
Nint HSF_API hfnet_set_httpd_process_cmd_func(hfhttpd_process_cmd_func_t pfunc);
Xint  hfnet_set_httpd_process_cmd_func(hfhttpd_process_cmd_func_t pfunc);
N
Nint  HSF_API hfnet_get_dhcp_ip (int * ip, int *mask, int *gw);
Xint   hfnet_get_dhcp_ip (int * ip, int *mask, int *gw);
N
Nint ping(char* ip_address);
N
N#define hfnet_ping(_ipadr)		ping(_ipadr)
N
Nint HSF_IAPI hfnet_send_assis_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
Xint  hfnet_send_assis_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
N
Nint HSF_API hfnet_start_assis_ex(uint16_t port,hfnet_callback_t p_callback);
Xint  hfnet_start_assis_ex(uint16_t port,hfnet_callback_t p_callback);
N
Nint HSF_API hfnet_assis_write(char *rep,int len,uint32_t addr,uint16_t port);
Xint  hfnet_assis_write(char *rep,int len,uint32_t addr,uint16_t port);
N
Nint HSF_API hfnet_gethostbyname(const char *name, ip_addr_t *addr);
Xint  hfnet_gethostbyname(const char *name, ip_addr_t *addr);
N
Nint HSF_API hfnet_start_assis(uint16_t port);
Xint  hfnet_start_assis(uint16_t port);
N
Nint HSF_API hfnet_start_httpd(uint32_t uxpriority);
Xint  hfnet_start_httpd(uint32_t uxpriority);
N
Nint HSF_API hfnet_start_socketb(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
Xint  hfnet_start_socketb(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
N
Nint HSF_API hfnet_start_socketa(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
Xint  hfnet_start_socketa(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
N
Nint HSF_API  hfnet_start_uart(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
Xint   hfnet_start_uart(uint32_t uxpriority,hfnet_callback_t p_uart_callback);
N
Nint HSF_API hfnet_start_uart_ex(uint32_t uxpriority,hfnet_callback_t p_callback, int stack_size);
Xint  hfnet_start_uart_ex(uint32_t uxpriority,hfnet_callback_t p_callback, int stack_size);
N
Nint  HSF_API hfnet_socketa_send(char *data,uint32_t len,uint32_t timeouts);
Xint   hfnet_socketa_send(char *data,uint32_t len,uint32_t timeouts);
N
Nint  HSF_API hfnet_socketa_eanble_clrtimeout_in_send(char b_enable);
Xint   hfnet_socketa_eanble_clrtimeout_in_send(char b_enable);
N
Nint HSF_API hfnet_socketb_send(char *data,uint32_t len,uint32_t timeouts);
Xint  hfnet_socketb_send(char *data,uint32_t len,uint32_t timeouts);
N
Nint HSF_IAPI hfnet_send_socketa_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
Xint  hfnet_send_socketa_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
N
Nint HSF_IAPI hfnet_send_socketb_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
Xint  hfnet_send_socketb_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
N
Nint HSF_API hfnet_socketa_fd(void);
Xint  hfnet_socketa_fd(void);
N
Nint HSF_API hfnet_socketb_fd(void);
Xint  hfnet_socketb_fd(void);
N
Nint HSF_API hfnet_socketa_get_client(int cid,phfnet_socketa_client_t p_client);
Xint  hfnet_socketa_get_client(int cid,phfnet_socketa_client_t p_client);
N
Nint HSF_IAPI hfnet_send_uart_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
Xint  hfnet_send_uart_event(uint32_t event,void *data,uint32_t len,uint32_t buf_len);
N
Nint HSF_IAPI hfnet_init(void);
Xint  hfnet_init(void);
N
Nint HSF_API hfnet_wifi_is_active(void);
Xint  hfnet_wifi_is_active(void);
N
Nint HSF_API  hfnet_wifi_up(void);
Xint   hfnet_wifi_up(void);
N
Nint HSF_API hfnet_wifi_down(void);
Xint  hfnet_wifi_down(void);
N
Nint HSF_API hfnet_set_udp_broadcast_port_valid(uint16_t start_port,uint16_t end_port);
Xint  hfnet_set_udp_broadcast_port_valid(uint16_t start_port,uint16_t end_port);
N
Nint HSF_API hfnet_recvfrom(int s, void *mem, size_t len, int flags,
Xint  hfnet_recvfrom(int s, void *mem, size_t len, int flags,
N        struct sockaddr *from, socklen_t *fromlen,char * mac);
X        struct sockaddr *from, u32_t *fromlen,char * mac);
N
Nint HSF_API hfnet_get_mac_address_by_ip(uint32_t ipaddr,uint8_t *mac);
Xint  hfnet_get_mac_address_by_ip(uint32_t ipaddr,uint8_t *mac);
N
N
N#endif
N
N
L 65 "..\sdk\1.50\include\hsf.h" 2
N#include "hfuart.h"
L 1 "..\sdk\1.50\include\hfuart.h" 1
N/* 
N *hfuart.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N#ifndef _UART_H_H_H_
N#define _UART_H_H_H_
N
Ntypedef void * hfuart_handle_t;
N
N#define	HFUART0			(hfuart_handle_t)9
N#define 	HFUART1			(hfuart_handle_t)10
N
Nhfuart_handle_t HSF_API  hfuart_open(int uart_no);
Xhfuart_handle_t   hfuart_open(int uart_no);
N
Nint HSF_API  hfuart_close(hfuart_handle_t huart);
Xint   hfuart_close(hfuart_handle_t huart);
N
N
Nint HSF_API hfuart_send(hfuart_handle_t huart,char *data,uint32_t bytes,uint32_t timeouts);
Xint  hfuart_send(hfuart_handle_t huart,char *data,uint32_t bytes,uint32_t timeouts);
N
Nint HSF_API hfuart_recv(hfuart_handle_t huart,char *recv,uint32_t bytes,uint32_t timeouts);
Xint  hfuart_recv(hfuart_handle_t huart,char *recv,uint32_t bytes,uint32_t timeouts);
N
Nint HSF_API
Xint 
Nhfuart_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
N            struct timeval *timeout);
N
N#endif
N
L 66 "..\sdk\1.50\include\hsf.h" 2
N#include "hfusb.h"
L 1 "..\sdk\1.50\include\hfusb.h" 1
N
N#ifndef _HF_USB_H_H_
N#define _HF_USB_H_H_
N
N
N
N
N#endif
N
L 67 "..\sdk\1.50\include\hsf.h" 2
N#include "hftimer.h"
L 1 "..\sdk\1.50\include\hftimer.h" 1
N
N/* hftimer.h
N *
N * Copyright (C) 2013 High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef HFTIMER_H_
N#define HFTIMER_H_
N
Ntypedef void * hftimer_handle_t;
N
N#define HFTIMER_FLAG_HARDWARE_TIMER				(0x00000001)
N
N/* Define the prototype to which timer callback functions must conform. */
Ntypedef void (*hf_timer_callback)( hftimer_handle_t htimer );
N
Nfloat HSF_IAPI hftimer_get_timer_adjust_factor(void);
Xfloat  hftimer_get_timer_adjust_factor(void);
N
Nhftimer_handle_t HSF_API  hftimer_create( const char *name, int32_t period, bool auto_reload,uint32_t  timer_id, hf_timer_callback p_callback,uint32_t flags );
Xhftimer_handle_t   hftimer_create( const char *name, int32_t period, bool auto_reload,uint32_t  timer_id, hf_timer_callback p_callback,uint32_t flags );
N
Nuint32_t  HSF_API hftimer_get_timer_id( hftimer_handle_t htimer );
Xuint32_t   hftimer_get_timer_id( hftimer_handle_t htimer );
N
Nvoid HSF_API  hftimer_delete(hftimer_handle_t htimer);
Xvoid   hftimer_delete(hftimer_handle_t htimer);
N
Nint HSF_API hftimer_start(hftimer_handle_t htimer);
Xint  hftimer_start(hftimer_handle_t htimer);
N
Nvoid HSF_API  hftimer_stop(hftimer_handle_t htimer);
Xvoid   hftimer_stop(hftimer_handle_t htimer);
N
Nvoid HSF_API hftimer_change_period(hftimer_handle_t htimer,int32_t new_period);
Xvoid  hftimer_change_period(hftimer_handle_t htimer,int32_t new_period);
N
Nuint32_t HSF_API hftimer_get_counter(hftimer_handle_t htimer);
Xuint32_t  hftimer_get_counter(hftimer_handle_t htimer);
N
Nint HSF_IAPI hftimer_auto_adjust(void);
Xint  hftimer_auto_adjust(void);
N
Nbool HSF_IAPI hftimer_is_adjust(void);
Xbool  hftimer_is_adjust(void);
N
N
N#endif /* HFTIMER_H_ */
N
N
L 68 "..\sdk\1.50\include\hsf.h" 2
N#include "hftime.h"
L 1 "..\sdk\1.50\include\hftime.h" 1
N
N/* hftime.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N
N#ifndef HFTIME_H_
N#define HFTIME_H_
N
N#ifdef CONFIG_NO_STRUCT_TIMEZONE
Nstruct timezone 
N{
N	char none;
N};
N#endif
N
N#if !CONFIG_HAVE_SETTIMEOFDAY
X#if !0
Nint HSF_API settimeofday(const struct timeval * tv, const struct timezone *tz);
Xint  settimeofday(const struct timeval * tv, const struct timezone *tz);
N#endif
N
N#if !CONFIG_HAVE_GETTIMEOFDAY
X#if !0
Nint HSF_API gettimeofday(struct timeval *__p, void *__tz);
Xint  gettimeofday(struct timeval *__p, void *__tz);
N#endif
N
N
N
N#endif /* HFTIME_H_ */
N
N
N
L 69 "..\sdk\1.50\include\hsf.h" 2
N#include "hffile.h"
L 1 "..\sdk\1.50\include\hffile.h" 1
N
N
N/* hffile.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N
N#ifndef _H_H_HFFILE_H_
N#define _H_H_HFFILE_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Ntypedef void * HFFILE;
N
N//current postion of the file
N#define HFFILE_SEEK_CUR		0
N
N//begin of the file
N#define HFFILE_SEEK_SET		1
N
N//end of the file
N//#define HFFILE_SEEK_END	1
N
Nint HSF_API  hffile_userbin_write(uint32_t offset,char *data,int len);
Xint   hffile_userbin_write(uint32_t offset,char *data,int len);
Nint HSF_API  hffile_userbin_read(uint32_t offset,char *data,int len);
Xint   hffile_userbin_read(uint32_t offset,char *data,int len);
Nint HSF_API hffile_userbin_size(void);
Xint  hffile_userbin_size(void);
Nint HSF_API hffile_userbin_zero(void);
Xint  hffile_userbin_zero(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* HFSYS_H_ */
L 70 "..\sdk\1.50\include\hsf.h" 2
N#include "hfupdate.h"
L 1 "..\sdk\1.50\include\hfupdate.h" 1
N/* 
N *hferrno.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N *
N */
N#ifndef __HF_UPDATE__H__
N#define __HF_UPDATE__H__
N
N
Ntypedef enum HFUPDATE_TYPE
N{
N	HFUPDATE_SW=0,
N	HFUPDATE_CONFIG=1,
N	HFUPDATE_WIFIFW,
N	HFUPDATE_WEB,
N}HFUPDATE_TYPE_E;
N
Nint HSF_API hfupdate_start(HFUPDATE_TYPE_E type);
Xint  hfupdate_start(HFUPDATE_TYPE_E type);
N
Nint HSF_API hfupdate_write_file(HFUPDATE_TYPE_E type ,uint32_t offset,char *data,int len);
Xint  hfupdate_write_file(HFUPDATE_TYPE_E type ,uint32_t offset,char *data,int len);
N
Nint HSF_API hfupdate_complete(HFUPDATE_TYPE_E type,uint32_t file_total_len);
Xint  hfupdate_complete(HFUPDATE_TYPE_E type,uint32_t file_total_len);
N
Nint HSF_API hfupdate_auto_upgrade(uint32_t flags);
Xint  hfupdate_auto_upgrade(uint32_t flags);
N
Nint HSF_IAPI hfupdate_auto_upgrade_default(void);
Xint  hfupdate_auto_upgrade_default(void);
N
N
N#endif
N
N
N
L 71 "..\sdk\1.50\include\hsf.h" 2
N#include "hfflash.h"
L 1 "..\sdk\1.50\include\hfflash.h" 1
N
N/* hfflash.h
N *
N * Copyright (C) 2013 High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef _HF_FLASH_H_H_H_
N#define _HF_FLASH_H_H_H_
N
N
Nint HSF_API hfuflash_erase_page(uint32_t addr, int pages);
Xint  hfuflash_erase_page(uint32_t addr, int pages);
N
Nint HSF_API hfuflash_write(uint32_t addr, char *data, int len);
Xint  hfuflash_write(uint32_t addr, char *data, int len);
N
Nint HSF_API hfuflash_read(uint32_t addr, char *data, int len);
Xint  hfuflash_read(uint32_t addr, char *data, int len);
N
Nint HSF_IAPI hfflash_copy(uint32_t dstaddr,uint32_t srcaddr,uint32_t len);
Xint  hfflash_copy(uint32_t dstaddr,uint32_t srcaddr,uint32_t len);
N
Nvoid flash_lock(void);
Nvoid flash_unlock(void);
Nint  flash_write(unsigned int addr, char *data, int len, int no_used);
Nint  flash_erase_page(unsigned int addr, int pages);
Nint  flash_read(unsigned int addr, char *data, int len, int no_used);
N
Nint  flash_write_no_lock(unsigned int addr, char *data, int len, int no_used);
N
Nint  flash_erase_page_no_lock(unsigned int addr, int pages);
N
N#define HFFLASH_PAGE_SIZE			(4*1024)
N
N#endif
N
L 72 "..\sdk\1.50\include\hsf.h" 2
N#include "hfflashlayout.h"
L 1 "..\sdk\1.50\include\hfflashlayout.h" 1
N
N#ifndef _HF_FLASH_LAYOUT_H_H_H_
N#define _HF_FLASH_LAYOUT_H_H_H_
N
N//#define CONFIG_FLASH_SIZE_1MB
N
N#ifdef CONFIG_FLASH_SIZE_1MB
S
S#define MAX_SOFTWARE_CODE_SIZE				(400*1024)		//512KB
S#define MAX_USERCONFIG_SIZE					(16*1024)
S#define MAX_5931_FW_SIZE						(152*1024)
S
S// LPB100		1M Flash
S#define BOOT_CONFIG								0x000F5000
S#define BOOT_CONFIG_BACKUP					0x000F6000
S#define SOFTWARE_CODE_ADDR_END				0x00064000
S#define USERPAGE 								0x00064000		// 400K
S#define CONFIGPAGE 								0x00064800
S#define USERPAGE_BACKUP 						0x00065000
S#define CONFIGPAGE_BACKUP 						0x00065800
S#define F_SETTING_ADDRESS       					0x00066000 
S#define F_CONFIG_ADDRESS       					0x00066800
S#define NVRAM_ADDR_MAC             					0x00067000
S#define WIFI_FIRMWARE_ADDR					0x00068000
S#define WIFI_FIRMWARE_ADDR_END				0x0008E000		// end of firmware
S#define UPGRADE_ADDRESS						0x0008F000
S#define UPGRADE_ADDRESS_END					0x000F3000
S#define WEB_SCAN_TMPBUF                 				0x000F8000
S#define APSTA_CHANNEL_ADDR                 			0x000FA000
S#define ERROR_NUMBER_ADDR              				0x000FB000
S#define TIMER_ADJUST_FACTOR_ADDR              		0x000FC000
S
S#define USER_BIN_FILE_OFFSET					0x000FD000
S#define USER_BIN_FILE_SIZE						4*1024
S#define USER_BIN_FILE_BAK_OFFSET				0x000FE000
S#define MODULE_DIFFERENT_ADDR					0x000FF000
S
S// 2M Flash
S#define WEB_ADDRESS							0x00100000//0x0008F000//For test
S#define WEB_ADDRESS_END						0x00132000//0x000F3000//for test
S
N#else
N
N#define CONFIG_FLASH_SIZE_2MB
N// LPB100		2M Flash
N#define BOOT_CONFIG								0x000F5000
N#define BOOT_CONFIG_BACKUP					0x000F6000
N
N#define MAX_SOFTWARE_CODE_SIZE				(512*1024)		//512KB
N#define MAX_USERCONFIG_SIZE					(16*1024)
N#define MAX_5931_FW_SIZE						(152*1024)
N#define HFUFLASH_SIZE							(128*1024)
N#define HFUFLASH1_SIZE							(100*1024)
N
N#define SOFTWARE_CODE_ADDR_END				0x00080000
N#define UFLASH_ADDRESS							0x00099000
N#define USERPAGE 								0x000BE000
N#define CONFIGPAGE 								0x000BE800
N#define USERPAGE_BACKUP 						0x000BF000
N#define CONFIGPAGE_BACKUP 						0x000BF800
N#define F_SETTING_ADDRESS       					0x000C0000 
N#define F_CONFIG_ADDRESS       					0x000C0800
N#define NVRAM_ADDR_MAC             					0x000C1000
N#define WIFI_FIRMWARE_ADDR					0x000C6000
N#define WIFI_FIRMWARE_ADDR_END				0x000EC000		// end of firmware
N
N#define WEB_SCAN_TMPBUF                 				0x000F8000
N#define APSTA_CHANNEL_ADDR                 			0x000FA000
N#define ERROR_NUMBER_ADDR              				0x000FB000
N#define TIMER_ADJUST_FACTOR_ADDR              		0x000FC000
N
N#define USER_BIN_FILE_OFFSET					0x000FD000
N#define USER_BIN_FILE_SIZE						4*1024
N#define USER_BIN_FILE_BAK_OFFSET				0x000FE000
N#define MODULE_DIFFERENT_ADDR					0x000FF000
N
N
N// 2M Flash
N#define WEB_ADDRESS							0x00100000//0x0008F000//For test
N#define WEB_ADDRESS_END						0x00132000//0x000F3000//for test
N
N#define UFLASH1_ADDRESS						0x00157000
N
N#define UPGRADE_ADDRESS						0x00180000
N#define UPGRADE_ADDRESS_END					0x001FFFFF
N
N#endif
N
N#endif
N
N
N
L 73 "..\sdk\1.50\include\hsf.h" 2
N#include <hfir.h>
L 1 "..\sdk\1.50\include\hfir.h" 1
N
N/* hfir.h
N *
N * Copyright (C) 2013-2020 ShangHai High-flying Electronics Technology Co.,Ltd.
N *				  	All rights reserved.
N *
N * This file is part of HSF.
N *
N */
N
N#ifndef _HFIR_H_H_
N#define _HFIR_H_H_
N
N/*
N *
N **/
Nbool HSF_API  hfir_is_key_come(void);
Xbool   hfir_is_key_come(void);
N
N/*
N *
N **/
Nuint32_t  HSF_API  hfir_get_key_code(void);
Xuint32_t    hfir_get_key_code(void);
N
N/*
N *
N **/
Nbool HSF_API  hfir_is_continue_prs(void);
Xbool   hfir_is_continue_prs(void);
N
N/*
N *
N **/
Nvoid HSF_API  hfir_ignore_lead_header(bool is_ignore);
Xvoid   hfir_ignore_lead_header(bool is_ignore);
N
N
N#endif
N
L 74 "..\sdk\1.50\include\hsf.h" 2
N#include <hfwifi.h>
L 1 "..\sdk\1.50\include\hfwifi.h" 1
N
N/* hfwifi.h
N *
N * Copyright (C) 2013-2014 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N * 
N * Modify:
N * 2013-12-31 : Create by Jim
N */
N
N #ifndef __HF_WIFI_H_H__
N #define __HF_WIFI_H_H__
N
N#define AUTH_TYPE_OPEN				0
N#define AUTH_TYPE_SHARED			1
N#define AUTH_TYPE_WPAPSK			2
N#define AUTH_TYPE_WPA2PSK			3
N#define AUTH_TYPE_WPAPSKWPA2PSK	4
N
N#define ENC_TYPE_NONE					0
N#define ENC_TYPE_WEP					1
N#define ENC_TYPE_TKIP					2
N#define ENC_TYPE_AES					3
N#define ENC_TYPE_TKIPAES				4
N
Ntypedef struct _WIFI_SCAN_RESULT_ITEM
N {
N	uint8_t auth;
N	uint8_t encry;
N	uint8_t channel;
N	uint8_t rssi;
N	char    ssid[32+1];
N	uint8_t mac[6];
N	int       rssi_dbm;
N	int       sco;
N }WIFI_SCAN_RESULT_ITEM,*PWIFI_SCAN_RESULT_ITEM;
N
Ntypedef int (*hfwifi_scan_callback_t)( PWIFI_SCAN_RESULT_ITEM );
N
N
Nint HSF_API hfwifi_scan(hfwifi_scan_callback_t p_callback);
Xint  hfwifi_scan(hfwifi_scan_callback_t p_callback);
Nint HSF_API hfwifi_enable_ap_idle_auto_reset(int max_idle_time);
Xint  hfwifi_enable_ap_idle_auto_reset(int max_idle_time);
Nbool HSF_API hfwifi_get_existing_ssid_rssi(uint8_t *ssid, int *crssi);
Xbool  hfwifi_get_existing_ssid_rssi(uint8_t *ssid, int *crssi);
Nbool HSF_API hfwifi_set_scan_ssid(uint8_t *ssid);
Xbool  hfwifi_set_scan_ssid(uint8_t *ssid);
N
N
N #endif
N
N
L 75 "..\sdk\1.50\include\hsf.h" 2
N#include <hfsmtlk.h>
L 1 "..\sdk\1.50\include\hfsmtlk.h" 1
N
N/* hfsmtlk.h
N *
N * Copyright (C) 2013-2014 ShangHai High-flying Electronics Technology Co.,Ltd.
N *
N * This file is part of HSF.
N * 
N * Modify:
N * 2013-12-25 : Create by Jim
N */
N
N#ifndef _HFSMTLK_H_H_
N#define _HFSMTLK_H_H_
N#include "hfwifi.h"
N
N//#define  hfsmtlk_start()	hfat_send_cmd("AT+SMTLK\r\n", sizeof("AT+SMTLK\r\n")-1, NULL, 0)
Nint HSF_API  hfsmtlk_start(void);
Xint   hfsmtlk_start(void);
N
Nint HSF_API  hfsmtlk_stop(void);
Xint   hfsmtlk_stop(void);
N
Nint HSF_API hfsmtlk_enable_recv_data_from_router(int enable);
Xint  hfsmtlk_enable_recv_data_from_router(int enable);
N
Nint HSF_API  hfwps_start(int timeout);
Xint   hfwps_start(int timeout);
N
Ntypedef int (*hfsmtlk_recv_callback_t)( void * /*pkt_data*/,uint32_t /*pkt_length*/,uint8_t /*channel*/);
N
Ntypedef int (*hfsmtlk_main_callback_t)( PWIFI_SCAN_RESULT_ITEM /*ap_list*/,uint32_t /*ap_cnt*/);
N
Nint HSF_API hfsmtlk_register(hfsmtlk_main_callback_t main_callback,hfsmtlk_recv_callback_t recv_callback);
Xint  hfsmtlk_register(hfsmtlk_main_callback_t main_callback,hfsmtlk_recv_callback_t recv_callback);
N
N#define HFSMTLK_FLAG_RECV_MGT_PKT			0x00000001
N#define HFSMTLK_FLAG_CHNL_EXT_SCA			0x00010000
N#define HFSMTLK_FLAG_CHNL_EXT_SCB			0x00020000
N
Nint HSF_API hfsmtlk_set_filter(uint8_t channel,uint8_t rssi,uint32_t max_pkt_len,uint32_t min_pkt_len,uint32_t flags);
Xint  hfsmtlk_set_filter(uint8_t channel,uint8_t rssi,uint32_t max_pkt_len,uint32_t min_pkt_len,uint32_t flags);
N
Nvoid HSF_API hfsmtlk_finished_ok(char *key, int type, uint8_t *apmac,char *ssid);
Xvoid  hfsmtlk_finished_ok(char *key, int type, uint8_t *apmac,char *ssid);
N
N#endif
N
N
L 76 "..\sdk\1.50\include\hsf.h" 2
N#ifdef __LPB100U__
S#include <hfusbhosthcd.h>
S#include <hfaudio.h>
N#endif
N
N#endif
N
N
L 2 "..\src\xlink_Application.c" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 3 "..\src\xlink_Application.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 4 "..\src\xlink_Application.c" 2
N#include <time.h>
N#include "xlink_demo.h"
L 1 "..\src\xlink_demo.h" 1
N/*
N * xlink_AppPassthrough.h
N *
N *  Created on: 2014骞1222
N *      Author: john
N */
N
N#ifndef XLINK_APPPASSTHROUGH_H_
N#define XLINK_APPPASSTHROUGH_H_
N
N#include "xlink_system.h"
L 1 "..\xlink\xlink_system.h" 1
N/*
N * xlink_system.h
N *
N *  Created on: 2014楠锟2锟9锟
N *      Author: john
N *
N * 缁ょ埠瀛煎版瀣锟
N *     1浣诡肩化ょ埠锟筋块宠瀵16娑瑙诡猴拷
N *     2浣哥宥诡绢绛lag[4] 规矮绠娴锟芥绱妯尖娣锟芥俊娓舵晶插缁ｇ娓剁浣割lagㄥ锟
N */
N
N#ifndef XLINK_SYSTEM_H_
N#define XLINK_SYSTEM_H_
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N#include "Xlink_Head_Adaptation.h"
L 1 "..\xlink\Xlink_Head_Adaptation.h" 1
N/*
N * Xlink_Head_Adaptation.h
N *
N *  Created on: 2015骞39
N *      Author: John
N */
N
N#ifndef SRC_XLINK_HEAD_ADAPTATION_H_
N#define SRC_XLINK_HEAD_ADAPTATION_H_
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N#include "xlink_type.h"
L 1 "..\xlink\xlink_type.h" 1
N#ifndef _XLINK_TYPE_
N#define _XLINK_TYPE_
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N#define xlink_true 0x01
N#define xlink_false 0x00
N
N#define xlink_success 0x00
N#define xlink_error  0x01
N
N#define XLINK_SIZE_17 17
N#define XLINK_SIZE_33 33
N#define XLINK_MAC_SIZE 6
N
Ntypedef unsigned char x_bool;
Ntypedef char x_int8;
Ntypedef unsigned char x_uint8;
Ntypedef short x_int16;
Ntypedef unsigned short x_uint16;
Ntypedef int x_int32;
Ntypedef unsigned int x_uint32;
Ntypedef int x_float32;
Ntypedef long x_long32;
N
N#undef NULL
N#if defined(__cplusplus)
X#if 0L
S#define NULL 0
N#else
N#define NULL ((void *)0)
N
N#endif
N
N
Ntypedef int (*xlink_debug_fn)(const char* format, ...);
N
Ntypedef struct XLINK_SELECT {
N	int fd;
N	int (*recv_event)(int fd);
N} XLINK_SELECT;
N
N
Ntypedef enum XLINK_WIFI_STATUS {
N	XLINK_WIFI_CONNECTING, //connect wifi
N	XLINK_WIFI_CONNECT_TIMEROUT, //connect wifi timeout
N	XLINK_WIFI_CONNECT_SUCCESS, //connect wifi success
N	XLINK_WIFI_DISCONNECT, //
N	XLINK_WIFI_GET_IPADDRING, //
N	XLINK_WIFI_GET_IPADDR_SUCCESS, //
N} XLINK_WIFI_STATUS;
N
Ntypedef enum XLINK_ERROR {
N	XLINK_ERROR_UDP_CREATE, //
N	XLINK_ERROR_EVENT_TIMEOUT, //
N	XLINK_ERROR_UART_OPEN_FAILED, //
N	XLINK_ERROR_NOT_WORK_TATUS, //
N} XLINK_ERROR;
N
N/**
N * flash 妯哄缂寸
N */
Ntypedef struct XLINK_CONFIG_T {
N	union {/*娣婵ㄩ板娣浼*/
N		unsigned char All;
N		struct {
N			unsigned char isActivation :1;/*濠碉拷妞*/
N			unsigned char isUpgrade :1;/*╅*/
N			unsigned char isSaveDevicekey :1;/*娣婵ㄦevice key*/
N			unsigned char isAppSetName :1;/*APP瀛奸宥*/
N			unsigned char isChangedPassword :1;/*娣芥肩靛*/
N			unsigned char isSetPassword :1;/*瀹歌绮＄х剧靛*/
N			unsigned char isAppSetPasswork :1;/*PP瀹歌绮＄х剧靛,Appх剧靛搴ゎ婢跺绗虫ㄩ扮*/
N			unsigned char res :1;
N		} Bit;
N	} flag;
N	unsigned char  Deviceid[4];/*娣婵Deviceid*/
N	unsigned short CurrentSoftVersion;
N} xlink_SdkConfig;
N
N
N
N
N//typedef enum XLINK_DATA_TYPE {
N//	XLINK_NONE = 0, //
N//	XLINK_BYTE = 1,/*1byte*/
N//	XLINK_INT16 = 2,/*2byte*/
N//	XLINK_INT32 = 3, /*4byte*/
N//} XLINK_DATA_TYPE;
N
N//typedef struct XLINK_DATAPOINT {
N//	XLINK_DATA_TYPE type;/*宓缁璇茬*/
N//	unsigned char index; /*缁便绱╂瀣*/
N//	unsigned char used; /*澶版锟/
N//	unsigned char flag; /*х缂婊锟芥茶*/
N//	unsigned short DataSize;/*濮诡炬婢堆  妤娑琚ㄥ″叉ㄩ瑙诡娓剁浣告躬妤娑ユ辨达缚绗+2 濮娑濠ｇ诡辨达妇娈2yte锟/
N//	unsigned int v_data;
N//} XLINK_DATAPOINT;
N
Ntypedef enum XLINK_APP_STATUS {
N	XLINK_WIFI_STA_PRO_TESTCOMPLETE=0X02,//娴绁寸瑰本
N	XLINK_WIFI_STA_CONNECT_SERVER = 0X04,  //剧甯存濠绨宥濮ｏ拷
N	XLINK_WIFI_STA_DISCONNCT_SERVER = 0X08,  //娑搴绨宥濮ｃ瀵锟芥奸猴拷
N	XLINK_WIFI_STA_APP_CONNECT = 0X10,  //APP╃村复
N	XLINK_WIFI_STA_APP_DISCONNECT = 0X20,  //APP 绱╃村复
N	XLINK_WIFI_STA_APP_TIMEOUT = 0X40,  //APP 妞
N	XLINK_WIFI_STA_LOGIN_SUCCESS = 0X80,  //ц茬缍宥濮ｃ锟
N} XLINK_APP_STATUS;
N
N/**
N * 恒归婀虫恒╋拷╅娣浼
N */
Ntypedef struct XLINK_UPGRADE_FUN {
N	unsigned int fileSize;
N	char *checkStr;
N	unsigned int checkStrLength;
N	char *urlstr;
N	unsigned short urlLength;
N	unsigned char mCheckFlag;
N	unsigned char mHardVersion;
N	unsigned short mSoftVersion;
N    unsigned short mCurrentVersion;
N	unsigned char isWifi;
N} XLINK_UPGRADE;
N
Ntypedef struct XLINK_TIME {
N	unsigned short year;
N	unsigned char mon;
N	unsigned char day;
N	unsigned char week;
N	unsigned char hour;
N	unsigned char min;
N	unsigned char sec;
N	short zones;
N} XLINK_SYS_TIME;
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif
N
L 14 "..\xlink\Xlink_Head_Adaptation.h" 2
N
N#define HF_SDK                  1//姹
N#define HF_SDK_A21              0
N#define MARVELL_SDK          	0//marvell
N#define QCA4004             	0//楂4004
N#define REALTEK              	0//realtek
N#define REALTEK_8711            0
N#define NL6621                  0//板哺绾
N#define __LWIP__ESP_8266     	0//
N#define __HED_10W07SN__         0//寰
N#define __MT7681__           	0
N#define __LINUX__             	0
N#define __STM32F107__           0
N
N#define __LSD4WF_2MD05101__     0   //LI ER DA
N#define __RTOS_STM32F103__      0
N#define __RTOS_STM32F107__      0
N#define __STM32F103_UIP__       0
N#define __MXCHIP__             	0
N
N#define __ALL_DEVICE__          0
N
N#define __XDEBUG__           	1
N
N#define __XLINK_VERSION__       30000
N
N#define __XLINK_BUFFER_PIPE__   1024
N
N#define __XLINK_STAND_HAIMAN__   0  //娴锋肩ㄧ讲
N
N//#define TEST_SERVER 
N
N#if HF_SDK
X#if 1
N
N#include "xlink_HF.h"
L 1 "..\xlink\xlink_HF.h" 1
N/*
N * xlink_HF.h
N *
N *  Created on: 2015骞96
N *      Author: XT800
N */
N
N#ifndef XLINK_HF_H_
N#define XLINK_HF_H_
N
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N
N#include <HSF.H>
N#include <STDLIB.H>
N#include <STRING.H>
N#include <STDIO.H>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\STDIO.H" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 19 "..\xlink\xlink_HF.h" 2
N#include <hfsys.h>
N#include <hfnet.h>
N#include <hfuart.h>
N
N#define  XLINK_FUNC   //USER_FUNC
N
N#define   xlink_strlen(x)      strlen(x)
N#define   xlink_strcmp(x,t)    strcmp((char*)(x),(char*)(t))
N#define   xlink_strncmp(x,t,z) strncmp((char*)(x),(char*)(t),z)
N#define   xlink_memset(x,d,t)  memset(x,d,t)
N#define   xlink_memcpy(x,d,l)  memcpy(x,d,l)
N#define   xlink_msleep(n)      msleep(n)
N
N#define   xlink_sprintf        sprintf
N
N#define   xlink_socket         socket
N#define   xlink_bind           bind
N#define   xlink_connect        connect
N#define   xlink_setsockopt     setsockopt
N#define   xlink_recv           recv
N#define   xlink_recvfrom       recvfrom
N#define   xlink_sendto         sendto
N#define   xlink_send           send
N#define   xlink_close(x)      close(x)
N#define   xlink_set_fd        fd_set
N#define   xlink_select(a,b,c,d,e)       hfuart_select(a,b,c,d,e)
N
N
Ntypedef time_t xsdk_time_t;
Ntypedef struct sockaddr_in xlink_addr;
N
N
N#ifdef  __cplusplus
S}
N#endif
N#endif /* XLINK_HF_H_ */
L 49 "..\xlink\Xlink_Head_Adaptation.h" 2
N#elif HF_SDK_A21
S
S#include "ic_head/xlink_HF_A21.h"
S
S#elif  MARVELL_SDK
S
S#include "ic_head/xlink_MARVELL_200.h"
S
S#elif   QCA4004
S
S#include "ic_head/xlink_QCA4004.h"
S
S#elif   REALTEK
S
S#include "ic_head/xlink_REALTEK_8195.h"
S
S#elif REALTEK_8711
S
S#include "ic_head/xlink_REALTEK_8711.h"
S
S#elif   NL6621
S
S#include "ic_head/xlink_NL6621.h"
S
S#elif   __LWIP__ESP_8266
S
S#include "ic_head/xlink_ESP8266.h"
S
S#elif  __MT7681__
S
S#include "ic_head/xlink_MT7681.h"
S
S#elif __STM32F107__
S
S#include "ic_head/xlink_stm32_lwip.h"
S
S#elif __HED_10W07SN__
S
S#include "ic_head/xlink_HED10W07SN.h"
S
S#elif __LINUX__
S
S#include "ic_head/xlink_linux.h"
S
S#elif __LSD4WF_2MD05101__
S
S#include "ic_head/xlink_LSD4WF2MD05101.h"
S
S#elif __RTOS_STM32F103__
S
S#include "ic_head/xlink_stm32_rtos.h"
S
S#elif __STM32F103_UIP__
S
S#include "ic_head/xlink_stm32_uip.h"
S
S#elif __MXCHIP__
S
S#include "ic_head/xlink_MXCHIP_mico.h"
S
S#elif __ALL_DEVICE__
S
S#include "ic_head/xlink_All_Device.h"
S
N#endif
N
N
N#define XLINK_MAC_LEN_MAX 32
N#define XLINK_MAC_LEN_MIN 1
N
Ntypedef struct XLINK_CALLBACK_FUN {
N	//ユ舵″ㄥ箍璋芥
N	void (*tcp_pipe2)(unsigned char * Buffer, unsigned int BufferLen, x_uint8 *opt);
N	//ユAPP杩″ㄥ版璋芥
N	void (*tcp_pipe)(unsigned char * Buffer, unsigned int BufferLen, x_uint32 AppID, x_uint8 *opt);
N	//ユAPP杩板版璋芥
N	void (*udp_pipe)(unsigned char * Buffer, unsigned int BufferLen,xlink_addr *fromAddr);
N
N	//void (*udp_proTest)(const unsigned char *Buffer,const unsigned char BufferLen,const unsigned short data_id,xlink_addr *fromAddr);
N	//SDK ㄥ缃璋芥帮瑕灏姝ゆ版flash
N	int (*writeConfig)(char *Buffer, unsigned int BufferLen);
N	//SDK ㄨ绘扮缃浠讹瑕璇诲flash缃版
N	int (*readConfig)(char *Buffer, unsigned int BufferLen);
N	//SDK ㄧ舵淇℃璋
N	void (*status)(XLINK_APP_STATUS status);
N	//SDK 跺版″ㄥ绾т俊璋
N	void (*upgrade)(XLINK_UPGRADE *data);
N	//SDK 跺版″ㄥ姝ユ堕翠俊璋
N	void (*server_time)(XLINK_SYS_TIME *time_p);
N	//SDK ㄦュ杈哄璋
N	xlink_debug_fn DebugPrintf;
N	//WiFi绫诲
N	unsigned char wifi_type;
N	//WiFi
N	unsigned short wifisoftVersion;
N	x_uint8 mcuHardwareVersion; /*Hardware Version*/
N	x_uint16 mcuHardwareSoftVersion;/*Software Version*/
N	//绔圭
N	//unsigned short endpointVersion;//绔圭
N	//SDK ㄦ浣跨TCP缃杩
N	unsigned char in_internet;
N	//璁惧MAC板
N    unsigned short maclen;
N	unsigned char mac[XLINK_MAC_LEN_MAX];
X	unsigned char mac[32];
N    
N    //纭浠跺璁浼璁,0琛ㄧず浼锛1琛ㄧず浼瀹逛负纭浠堕璁璁
N    unsigned char pipetype;
N    //璁惧绫诲
N    unsigned short devicetype;
N
N
N
N#if  __LWIP__ESP_8266 || __MT7681__ || __STM32F107__ || __STM32F103_UIP__ || __ALL_DEVICE__
X#if  0 || 0 || 0 || 0 || 0
S    unsigned char *tcpRecvBuffer;
S    unsigned int tcpRecvBuuferLength;
S    int (*send_udp)(xlink_addr *addr, unsigned char *data, unsigned int datalen);
S    int (*send_tcp)(unsigned char *data, unsigned int datalen);
S    void (*setServerStatus)(unsigned char stat,unsigned char is80Port);
S    void (*process_udp_data)(unsigned char * Buffer, unsigned int BufferLen, xlink_addr *addrBro);
S    void (*process_tcp_data)(unsigned char * data, unsigned int datalen, x_uint32 bodylen);
N#endif
N
N
N	//V2 datapoint
N	//datapoint format:[datapoint index:1byte][datalen:2bytes(H L)][data:datalen bytes]...
N	void (*Xlink_SetDataPoint)(unsigned char *data, int datalen);//app->wifi,you can update datapoints by this buf
N	void (*Xlink_GetAllDataPoint)(unsigned char *data, int *datalen);//add all datapoint data to the buf,The maximum length is XLINK_DATAPOINT_MAX_BYTES
N} XLINK_USER_CONFIG;
Nextern XLINK_FUNC void XlinkPorcess_UDP_Enable(void);
Xextern  void XlinkPorcess_UDP_Enable(void);
Nextern XLINK_FUNC void XlinkPorcess_UDP_Disable(void);
Xextern  void XlinkPorcess_UDP_Disable(void);
Nextern XLINK_FUNC void XlinkReSetSDK(void);
Xextern  void XlinkReSetSDK(void);
N
N#ifdef  __cplusplus
S}
N#endif
N#endif /* SRC_XLINK_HEAD_ADAPTATION_H_ */
L 18 "..\xlink\xlink_system.h" 2
N
N#if __ALL_DEVICE__
X#if 0
S    enum TCP_ {
S        E_TCP_SUCCESS, E_TCP_CONTINUE, //
S        E_TCP_HEAD_ERROR, //
S        E_TCP_NO_MEM,
S        E_TCP_READ_MEM_ERROR,
S    };
N#endif
N
Nextern XLINK_FUNC char *XlinkSystemVersion(void);
Xextern  char *XlinkSystemVersion(void);
N
Nextern XLINK_FUNC x_bool XlinkSystemInit(char * product_id, char * product_key, XLINK_USER_CONFIG *config);
Xextern  x_bool XlinkSystemInit(char * product_id, char * product_key, XLINK_USER_CONFIG *config);
N
Nextern XLINK_FUNC void XlinkSystemSetWifiStatus(unsigned char status);
Xextern  void XlinkSystemSetWifiStatus(unsigned char status);
N
Nextern XLINK_FUNC void XlinkSystemLoop(xsdk_time_t c_time, x_int32 timeout_ms);
Xextern  void XlinkSystemLoop(xsdk_time_t c_time, x_int32 timeout_ms);
N
Nextern XLINK_FUNC void XlinkSystemSetLocalScanStatus(x_bool status);
Xextern  void XlinkSystemSetLocalScanStatus(x_bool status);
N
Nextern XLINK_FUNC void XlinkSystemSetPassword(char *password);
Xextern  void XlinkSystemSetPassword(char *password);
N
Nextern XLINK_FUNC void XlinkSystemClearPassword(char *password);
Xextern  void XlinkSystemClearPassword(char *password);
N
Nextern XLINK_FUNC void XlinkSystemSetDeviceName(char *NameStr);
Xextern  void XlinkSystemSetDeviceName(char *NameStr);
Nextern XLINK_FUNC void XlinkSystemSetDomain(const char *domain);
Xextern  void XlinkSystemSetDomain(const char *domain);
N
Nextern XLINK_FUNC void XlinkSystemReSet(void);
Xextern  void XlinkSystemReSet(void);
N
Nextern XLINK_FUNC void XlinkNetInit(void);
Xextern  void XlinkNetInit(void);
N
Nextern XLINK_FUNC x_int32 XlinkSendTcpPipe(const unsigned char * data,const unsigned int datalen, x_uint32 to_id);
Xextern  x_int32 XlinkSendTcpPipe(const unsigned char * data,const unsigned int datalen, x_uint32 to_id);
N
Nextern XLINK_FUNC x_int32 XlinkSendTcpPipe2(const unsigned char * data,const unsigned int datalen);
Xextern  x_int32 XlinkSendTcpPipe2(const unsigned char * data,const unsigned int datalen);
N
Nextern XLINK_FUNC x_int32 XlinkSendUdpPipe(const unsigned char *data, const unsigned int datalen, xlink_addr *fromAddr);
Xextern  x_int32 XlinkSendUdpPipe(const unsigned char *data, const unsigned int datalen, xlink_addr *fromAddr);
N
Nextern XLINK_FUNC void XlinkGetServerTime(void);
Xextern  void XlinkGetServerTime(void);
Nextern XLINK_FUNC int XlinkGetSystemTime(XLINK_SYS_TIME *pTime);
Xextern  int XlinkGetSystemTime(XLINK_SYS_TIME *pTime);
N
Nextern XLINK_FUNC void XlinkSystemInitEvent(XLINK_SELECT *event);
Xextern  void XlinkSystemInitEvent(XLINK_SELECT *event);
N
Nextern XLINK_FUNC int XlinkSystemTcpLoop(void);
Xextern  int XlinkSystemTcpLoop(void);
Nextern XLINK_FUNC int xsdk_system_getMacStr(char *RetMacBuffer, const int bufflen);
Xextern  int xsdk_system_getMacStr(char *RetMacBuffer, const int bufflen);
N
Nextern XLINK_FUNC int XlinkProTestSendData(const char *data,const unsigned char datalen,const unsigned char data_id,xlink_addr *toAddr);
Xextern  int XlinkProTestSendData(const char *data,const unsigned char datalen,const unsigned char data_id,xlink_addr *toAddr);
N
Nextern XLINK_FUNC int XlinkProTestSendCloseRequest(xlink_addr *toAddr);
Xextern  int XlinkProTestSendCloseRequest(xlink_addr *toAddr);
N
Nextern XLINK_FUNC int XlinkSystemProtesting(void);
Xextern  int XlinkSystemProtesting(void);
Nextern XLINK_FUNC int XlinkSystemGetDeviceID(void);
Xextern  int XlinkSystemGetDeviceID(void);
N
Nextern XLINK_FUNC void Xlink_UpdateDataPoint(unsigned char* data, x_uint16 datalen,unsigned char flag);
Xextern  void Xlink_UpdateDataPoint(unsigned char* data, x_uint16 datalen,unsigned char flag);
N
Nextern XLINK_FUNC void XlinkSetACK(int accesskey);
Xextern  void XlinkSetACK(int accesskey);
Nextern XLINK_FUNC int XlinkGetACK(void);
Xextern  int XlinkGetACK(void);
N
Nextern XLINK_FUNC  void xlink_tcp_send_upgrade(unsigned char RetCode,unsigned short Upver,unsigned short currentVer) ;
Xextern   void xlink_tcp_send_upgrade(unsigned char RetCode,unsigned short Upver,unsigned short currentVer) ;
N
Nextern XLINK_FUNC void Xlink_Close_Net(void);
Xextern  void Xlink_Close_Net(void);
N
Nextern XLINK_FUNC int XlinkProcessTCPData(void);
Xextern  int XlinkProcessTCPData(void);
Nextern XLINK_FUNC int XlinkPushData(unsigned char * data, x_int16 datalen);
Xextern  int XlinkPushData(unsigned char * data, x_int16 datalen);
Nextern XLINK_FUNC void XlinkProcessUdpData( unsigned char * Buffer, unsigned int BufferLen, xlink_addr *addr);
Xextern  void XlinkProcessUdpData( unsigned char * Buffer, unsigned int BufferLen, xlink_addr *addr);
N#if __ALL_DEVICE__
X#if 0
Sextern void XLINK_FUNC setServerStatus_(unsigned char stat,unsigned char is80Port);
N#endif
N#ifdef  __cplusplus
S}
N#endif
N#endif /* XLINK_SYSTEM_H_ */
L 12 "..\src\xlink_demo.h" 2
N
Nextern XLINK_FUNC int xlink_demo_init(void);
Xextern  int xlink_demo_init(void);
N
Nextern XLINK_FUNC void xlink_demo_loop(void);
Xextern  void xlink_demo_loop(void);
Nextern XLINK_FUNC void xlink_save_at_config(void);
Xextern  void xlink_save_at_config(void);
Nextern XLINK_FUNC void xlink_recv_uart_data(unsigned char *data,unsigned int datalen);
Xextern  void xlink_recv_uart_data(unsigned char *data,unsigned int datalen);
Nextern XLINK_FUNC int XlinkUartSend(unsigned char *Buffer, unsigned short BufferLen);
Xextern  int XlinkUartSend(unsigned char *Buffer, unsigned short BufferLen);
N
N#define XLINK_CONFIG_PRODUCTID_KEY   4
N#define XLINK_ID_KEY_LENGTH          64
N
N#define XLINK_UART_BUFFER_SIZE __XLINK_BUFFER_PIPE__
N
Ntypedef union {
N	unsigned char byte;
N	struct {
N		unsigned char isConnectedServer :1;
N		unsigned char isConnectWIFI :1;
N		unsigned char isNeedSend :1;
N		unsigned char isSendUartData :1;
N		unsigned char isNeedSendWifiSta:1;
N		unsigned char isNeedSendServerSta:1;
N		unsigned char res :2;
N	} bit;
N} XLINK_LOCAL_STA;
N
N#define UART_PACK_MAX 5
N#define UART_PACK_LEN 1024
Ntypedef struct{
N	uint8_t flag;
N	uint16_t len;
N	uint8_t  buf[UART_PACK_LEN];
X	uint8_t  buf[1024];
N}UART_SEND_PACK;
Nextern volatile  UART_SEND_PACK uart_send_pack[];
Nextern volatile int uart_send_pos;
N
Nextern XLINK_LOCAL_STA g_AllSta;
N
N
N
N#endif /* XLINK_APPPASSTHROUGH_H_ */
L 6 "..\src\xlink_Application.c" 2
N#include "xlink_at.h"
L 1 "..\src\xlink_at.h" 1
N/*
N * xlink_at.h
N *
N *  Created on: 2015骞81
N *      Author: XT800
N */
N
N#ifndef XLINK_AT_H_
N#define XLINK_AT_H_
N
N#define __X_AT_OK__ 5
N#define __X_CMD_SIZE_ 33
N#define __X_CMD_PARAM_COUNT_  5
N#define AT_VERSION   2
N
Ntypedef struct xlink_at_cmd {
N	const char * name;
N	int (*func)(int, char **argv);
N	const char * doc;
N} xlink_at_cmd_t;
N
Nextern int xlink_process_at_cmd(unsigned char *data, unsigned int datalen);
Nextern int xlink_send_uart_sta(void);
Nextern int xlink_start_smart(void);
N
Ntypedef struct {
N	union {
N		unsigned char byte;
N		struct {
N			unsigned char isSendSta :1;
N			unsigned char isSetMac :1;
N			unsigned char res :6;
N		} bit;
N	} flag;
N	char macString[13];
N} AT_CONFIG;
N
N#endif /* XLINK_AT_H_ */
L 7 "..\src\xlink_Application.c" 2
N
N#ifndef XLINK_FUNC
S#define XLINK_FUNC
N#endif
N
N#ifdef __LPT100__
Sstatic int module_type= HFM_TYPE_LPT100;
Sconst int hf_gpio_fid_to_pid_map_table[HFM_MAX_FUNC_CODE]=
S{
S	HFM_NOPIN,//HF_M_PIN(2),	//HFGPIO_F_JTAG_TCK
S	HFM_NOPIN,//HF_M_PIN(3),	//HFGPIO_F_JTAG_TDO
S	HFM_NOPIN,//HF_M_PIN(4),	//HFGPIO_F_JTAG_TDI
S	HFM_NOPIN,//HF_M_PIN(5),	//HFGPIO_F_JTAG_TMS
S	HFM_NOPIN,		//HFGPIO_F_USBDP
S	HFM_NOPIN,		//HFGPIO_F_USBDM
S	HF_M_PIN(39),	//HFGPIO_F_UART0_TX
S	HF_M_PIN(40),	//HFGPIO_F_UART0_RTS
S	HF_M_PIN(41),	//HFGPIO_F_UART0_RX
S	HF_M_PIN(42),	//HFGPIO_F_UART0_CTS
S	
S	HFM_NOPIN,//HF_M_PIN(27),	//HFGPIO_F_SPI_MISO
S	HFM_NOPIN,//HF_M_PIN(28),	//HFGPIO_F_SPI_CLK
S	HFM_NOPIN,//HF_M_PIN(29),	//HFGPIO_F_SPI_CS
S	HFM_NOPIN,//HF_M_PIN(30),	//HFGPIO_F_SPI_MOSI
S	
S	HFM_NOPIN,	//HFGPIO_F_UART1_TX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RTS,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_CTS,
S	
S	HF_M_PIN(11),	//HFGPIO_F_NLINK
S	HF_M_PIN(12),	//HFGPIO_F_NREADY
S	HF_M_PIN(45),	//HFGPIO_F_NRELOAD
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_RQ
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_ON
S	
S	HFM_NOPIN,//HF_M_PIN(18),	//HFGPIO_F_WPS
S	HFM_NOPIN,		//HFGPIO_F_RESERVE1
S	HFM_NOPIN,		//HFGPIO_F_RESERVE2
S	HFM_NOPIN,		//HFGPIO_F_RESERVE3
S	HFM_NOPIN,		//HFGPIO_F_RESERVE4
S	HFM_NOPIN,		//HFGPIO_F_RESERVE5
S	
S	//HFM_NOPIN,	//HFGPIO_F_USER_DEFINE
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HF_M_PIN(18),//connect server
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S};
S#elif defined(__LPT200__)
X#elif 0L
Sstatic int module_type= HFM_TYPE_LPT200;
Sconst int hf_gpio_fid_to_pid_map_table[HFM_MAX_FUNC_CODE]=
S{
S	HF_M_PIN(2),	//HFGPIO_F_JTAG_TCK
S	HF_M_PIN(3),	//HFGPIO_F_JTAG_TDO
S	HF_M_PIN(4),	//HFGPIO_F_JTAG_TDI
S	HF_M_PIN(5),	//HFGPIO_F_JTAG_TMS
S	HFM_NOPIN,		//HFGPIO_F_USBDP
S	HFM_NOPIN,		//HFGPIO_F_USBDM
S	HF_M_PIN(39),	//HFGPIO_F_UART0_TX
S	HF_M_PIN(40),	//HFGPIO_F_UART0_RTS
S	HF_M_PIN(41),	//HFGPIO_F_UART0_RX
S	HF_M_PIN(42),	//HFGPIO_F_UART0_CTS
S	
S	HFM_NOPIN,//HF_M_PIN(27),	//HFGPIO_F_SPI_MISO
S	HFM_NOPIN,//HF_M_PIN(28),	//HFGPIO_F_SPI_CLK
S	HFM_NOPIN,//HF_M_PIN(29),	//HFGPIO_F_SPI_CS
S	HFM_NOPIN,//HF_M_PIN(30),	//HFGPIO_F_SPI_MOSI
S	
S	HFM_NOPIN,	//HFGPIO_F_UART1_TX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RTS,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_CTS,
S	
S	HF_M_PIN(43),	//HFGPIO_F_NLINK
S	HF_M_PIN(44),	//HFGPIO_F_NREADY
S	HF_M_PIN(45),	//HFGPIO_F_NRELOAD
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_RQ
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_ON
S		
S	HF_M_PIN(7),		//HFGPIO_F_WPS
S	HFM_NOPIN,		//HFGPIO_F_RESERVE1
S	HFM_NOPIN,		//HFGPIO_F_RESERVE2
S	HFM_NOPIN,		//HFGPIO_F_RESERVE3
S	HFM_NOPIN,		//HFGPIO_F_RESERVE4
S	HFM_NOPIN,		//HFGPIO_F_RESERVE5
S	
S	//HFM_NOPIN,	//HFGPIO_F_USER_DEFINE
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HF_M_PIN(29),//connect server
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S};
N#elif defined(__LPB100__)
X#elif 1L
Nstatic int module_type= HFM_TYPE_LPB100;
Xstatic int module_type= 0;
Nconst int hf_gpio_fid_to_pid_map_table[HFM_MAX_FUNC_CODE]=
Xconst int hf_gpio_fid_to_pid_map_table[((48)*2)]=
N{
N	HF_M_PIN(2),	//HFGPIO_F_JTAG_TCK
X	((0x00080000)|2),	
N	HF_M_PIN(3),	//HFGPIO_F_JTAG_TDO
X	((0x00080000)|3),	
N	HF_M_PIN(4),	//HFGPIO_F_JTAG_TDI
X	((0x00080000)|4),	
N	HF_M_PIN(5),	//HFGPIO_F_JTAG_TMS
X	((0x00080000)|5),	
N	HFM_NOPIN,		//HFGPIO_F_USBDP
X	(0),		
N	HFM_NOPIN,		//HFGPIO_F_USBDM
X	(0),		
N	HF_M_PIN(39),	//HFGPIO_F_UART0_TX
X	((0x00080000)|((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|39),	
N	HFM_NOPIN,//HF_M_PIN(40),	//HFGPIO_F_UART0_RTS
X	(0),
N	HF_M_PIN(41),	//HFGPIO_F_UART0_RX
X	((0x00080000)|((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|41),	
N	HFM_NOPIN,//HF_M_PIN(42),	//HFGPIO_F_UART0_CTS
X	(0),
N	
N	HFM_NOPIN,//HF_M_PIN(27),	//HFGPIO_F_SPI_MISO
X	(0),
N	HFM_NOPIN,//HF_M_PIN(28),	//HFGPIO_F_SPI_CLK
X	(0),
N	HFM_NOPIN,//HF_M_PIN(29),	//HFGPIO_F_SPI_CS
X	(0),
N	HFM_NOPIN,//HF_M_PIN(30),	//HFGPIO_F_SPI_MOSI
X	(0),
N	
N	HFM_NOPIN,//HF_M_PIN(23),//HFM_NOPIN,	//HFGPIO_F_UART1_TX,
X	(0),
N	HFM_NOPIN,	//HFGPIO_F_UART1_RTS,
X	(0),	
N	HF_M_PIN(8),	//HFGPIO_F_UART1_RX,
X	(((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|(0x02000000)|8),	
N	HFM_NOPIN,	//HFGPIO_F_UART1_CTS,
X	(0),	
N	
N	HF_M_PIN(43),	//HFGPIO_F_NLINK
X	(((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|43),	
N	HF_M_PIN(44),	//HFGPIO_F_NREADY
X	(((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|44),	
N	HF_M_PIN(45),	//HFGPIO_F_NRELOAD
X	(((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|45),	
N	HFM_NOPIN,//HF_M_PIN(7),	//HFGPIO_F_SLEEP_RQ
X	(0),
N	HFM_NOPIN,//HF_M_PIN(8),	//HFGPIO_F_SLEEP_ON
X	(0),
N		
N	HFM_NOPIN,//HF_M_PIN(15),		//HFGPIO_F_WPS
X	(0),
N	HFM_NOPIN,		//HFGPIO_F_RESERVE1
X	(0),		
N	HFM_NOPIN,		//HFGPIO_F_RESERVE2
X	(0),		
N	HFM_NOPIN,		//HFGPIO_F_RESERVE3
X	(0),		
N	HFM_NOPIN,		//HFGPIO_F_RESERVE4
X	(0),		
N	HFM_NOPIN,		//HFGPIO_F_RESERVE5
X	(0),		
N	
N	//HFM_NOPIN,	//HFGPIO_F_USER_DEFINE
N
N	HFM_NOPIN,
X	(0),
N	HFM_NOPIN,
X	(0),
N	HFM_NOPIN,
X	(0),
N
N	HFM_NOPIN,
X	(0),
N	HFM_NOPIN,
X	(0),
N
N	HF_M_PIN(18),//connect server
X	(((0x00010000)|(0x00020000))|(0x00800000|(0x00010000))|(0x01000000)|18),
N	HFM_NOPIN,
X	(0),
N	HFM_NOPIN,
X	(0),
N
N	HFM_NOPIN,
X	(0),
N	HFM_NOPIN,
X	(0),
N};
N#elif defined(__LPB105__)
Sstatic int module_type= HFM_TYPE_LPB105;
Sconst int hf_gpio_fid_to_pid_map_table[HFM_MAX_FUNC_CODE]=
S{
S	HF_M_PIN(2),	//HFGPIO_F_JTAG_TCK
S	HF_M_PIN(3),	//HFGPIO_F_JTAG_TDO
S	HF_M_PIN(4),	//HFGPIO_F_JTAG_TDI
S	HF_M_PIN(5),	//HFGPIO_F_JTAG_TMS
S	HFM_NOPIN,		//HFGPIO_F_USBDP
S	HFM_NOPIN,		//HFGPIO_F_USBDM
S	HF_M_PIN(39),	//HFGPIO_F_UART0_TX
S	HFM_NOPIN,	//HFGPIO_F_UART0_RTS
S	HF_M_PIN(41),	//HFGPIO_F_UART0_RX
S	HFM_NOPIN,	//HFGPIO_F_UART0_CTS
S	
S	HF_M_PIN(27),	//HFGPIO_F_SPI_MISO
S	HF_M_PIN(28),	//HFGPIO_F_SPI_CLK
S	HF_M_PIN(29),	//HFGPIO_F_SPI_CS
S	HF_M_PIN(30),	//HFGPIO_F_SPI_MOSI
S	
S	HFM_NOPIN,	//HFGPIO_F_UART1_TX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RTS,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_CTS,
S	
S	HF_M_PIN(11),	//HFGPIO_F_NLINK
S	HF_M_PIN(44),	//HFGPIO_F_NREADY
S	HF_M_PIN(45),	//HFGPIO_F_NRELOAD
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_RQ
S	HFM_NOPIN,	//HFGPIO_F_SLEEP_ON
S	
S	HF_M_PIN(18),	//HFGPIO_F_WPS
S	HFM_NOPIN,		//HFGPIO_F_RESERVE1
S	HFM_NOPIN,		//HFGPIO_F_RESERVE2
S	HFM_NOPIN,		//HFGPIO_F_RESERVE3
S	HFM_NOPIN,		//HFGPIO_F_RESERVE4
S	HFM_NOPIN,		//HFGPIO_F_RESERVE5
S	
S	HFM_NOPIN,	//HFGPIO_F_USER_DEFINE
S};
S#elif defined(__LPB100U__)
Sstatic int module_type= HFM_TYPE_LPB100;
Sconst int hf_gpio_fid_to_pid_map_table[HFM_MAX_FUNC_CODE]=
S{
S	HF_M_PIN(2),	//HFGPIO_F_JTAG_TCK
S	HFM_NOPIN,	//HFGPIO_F_JTAG_TDO
S	HFM_NOPIN,	//HFGPIO_F_JTAG_TDI
S	HF_M_PIN(5),	//HFGPIO_F_JTAG_TMS
S	HFM_NOPIN,		//HFGPIO_F_USBDP
S	HFM_NOPIN,		//HFGPIO_F_USBDM
S	HF_M_PIN(39),	//HFGPIO_F_UART0_TX
S	HFM_NOPIN,//HF_M_PIN(40),	//HFGPIO_F_UART0_RTS
S	HF_M_PIN(41),	//HFGPIO_F_UART0_RX
S	HFM_NOPIN,//HF_M_PIN(42),	//HFGPIO_F_UART0_CTS
S	
S	HFM_NOPIN,//HF_M_PIN(27),	//HFGPIO_F_SPI_MISO
S	HFM_NOPIN,//HF_M_PIN(28),	//HFGPIO_F_SPI_CLK
S	HFM_NOPIN,//HF_M_PIN(29),	//HFGPIO_F_SPI_CS
S	HFM_NOPIN,//HF_M_PIN(30),	//HFGPIO_F_SPI_MOSI
S	
S	HF_M_PIN(29),	//HFGPIO_F_UART1_TX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_RTS,
S	HF_M_PIN(30),	//HFGPIO_F_UART1_RX,
S	HFM_NOPIN,	//HFGPIO_F_UART1_CTS,	
S	
S	HF_M_PIN(43),	//HFGPIO_F_NLINK
S	HF_M_PIN(44),	//HFGPIO_F_NREADY
S	HF_M_PIN(45),	//HFGPIO_F_NRELOAD
S	HF_M_PIN(7),	//HFGPIO_F_SLEEP_RQ
S	HF_M_PIN(8),	//HFGPIO_F_SLEEP_ON
S		
S	HF_M_PIN(15),		//HFGPIO_F_WPS
S	HFM_NOPIN,		//HFGPIO_F_RESERVE1
S	HFM_NOPIN,		//HFGPIO_F_RESERVE2
S	HFM_NOPIN,		//HFGPIO_F_RESERVE3
S	HFM_NOPIN,		//HFGPIO_F_RESERVE4
S	HFM_NOPIN,		//HFGPIO_F_RESERVE5
S	
S	//HFM_NOPIN,	//HFGPIO_F_USER_DEFINE
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HF_M_PIN(18),//connect server
S	HFM_NOPIN,
S	HFM_NOPIN,
S
S	HFM_NOPIN,
S	HFM_NOPIN,
S};
S#else
S#error "invalid project !you must define module type(__LPB100__,__LPT100__,_LPT200__)"
N#endif
N
Nconst hfat_cmd_t user_define_at_cmds_table[] = { { NULL, NULL, NULL, NULL } //the last item must be null
Xconst hfat_cmd_t user_define_at_cmds_table[] = { { 0, 0, 0, 0 } 
N};
N
Nvoid USER_FUNC airkiss_domain_lop(void *args);
Xvoid  airkiss_domain_lop(void *args);
N
Nstatic void show_reset_reason(void) {
N	uint32_t reset_reason = 0;
N
N	reset_reason = hfsys_get_reset_reason();
N
N#if 1
N	u_printf("reset_reasion:%08x\n", reset_reason);
X	HF_Debug(10,"reset_reasion:%08x\n", reset_reason);
N#else	
S	if(reset_reason&HFSYS_RESET_REASON_ERESET)
S	{
S		u_printf("ERESET\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_IRESET0)
S	{
S		u_printf("IRESET0\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_IRESET1)
S	{
S		u_printf("IRESET1\n");
S	}
S	if(reset_reason==HFSYS_RESET_REASON_NORMAL)
S	{
S		u_printf("RESET NORMAL\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_WPS)
S	{
S		u_printf("RESET FOR WPS\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_SMARTLINK_START)
S	{
S		u_printf("RESET FOR SMARTLINK START\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_SMARTLINK_OK)
S	{
S		u_printf("RESET FOR SMARTLINK OK\n");
S	}
S	if(reset_reason&HFSYS_RESET_REASON_WPS_OK)
S	{
S		u_printf("RESET FOR WPS OK\n");
S	}
N#endif
N
N	return;
N}
N
Nvoid app_init(void) {
N	u_printf("app_init\n");
X	HF_Debug(10,"app_init\n");
N}
N
NXLINK_FUNC void work_phtread(void *args) {
X void work_phtread(void *args) {
N	int ret = xlink_demo_init();
N	if (ret == 0) {
N		while (1) {
N			msleep(1000);
X			hf_thread_delay(1000);
N		}
N	}
N	xlink_demo_loop();
N}
N
NXLINK_FUNC void work_phtread_tcp_client(void *args) {
X void work_phtread_tcp_client(void *args) {
N	
N	while(1){
N			XlinkSystemTcpLoop();
N			msleep(2*1000);
X			hf_thread_delay(2*1000);
N	}
N}
N
N
Nstatic int hfsys_event_callback(uint32_t event_id, void * param) {
N	int ret = 0;
N	switch (event_id) {
N	case HFE_WIFI_STA_CONNECTED:
N		u_printf("wifi sta connected!!\n");
X		HF_Debug(10,"wifi sta connected!!\n");
N		g_AllSta.bit.isConnectWIFI = 1;
N		xlink_send_uart_sta();
N		XlinkSystemSetWifiStatus(1);
N		break;
N	case HFE_WIFI_STA_DISCONNECTED:
N		u_printf("wifi sta disconnected!!\n");
X		HF_Debug(10,"wifi sta disconnected!!\n");
N		g_AllSta.bit.isConnectWIFI = 0;
N		xlink_send_uart_sta();
N	  XlinkSystemSetWifiStatus(0);
N		break;
N	case HFE_DHCP_OK:
N		XlinkSystemSetWifiStatus(1);
N		break;
N	case HFE_SMTLK_OK:
N		u_printf("smtlk ok!\n");
X		HF_Debug(10,"smtlk ok!\n");
N		break;
N	case HFE_CONFIG_RELOAD:
N		u_printf("reload!\n");
X		HF_Debug(10,"reload!\n");
N		break;
N	default:
N		break;
N	}
N	return ret;
N}
N
Nstatic int USER_FUNC uart_recv_callback(uint32_t event,char *data,uint32_t len,uint32_t buf_len)
Xstatic int  uart_recv_callback(uint32_t event,char *data,uint32_t len,uint32_t buf_len)
N{
N	HF_Debug(DEBUG_LEVEL_LOW,"[%d]uart recv %d bytes data %d\n",event,len,buf_len);
X	HF_Debug(1,"[%d]uart recv %d bytes data %d\n",event,len,buf_len);
N	xlink_recv_uart_data((unsigned char *)data,len);
N	return len;
N}
N
N///main
Nint XLINK_FUNC app_main(void) {
Xint  app_main(void) {
N
N	//time_t now=time(NULL);
N//	hfdbg_set_level(DEBUG_LEVEL);
N	//XlinkUartSend("App start .\r\n", sizeof("App start .\r\n"));
N	HF_Debug(DEBUG_LEVEL, "sdk version(%s),the app_main start time is %s %s\n", hfsys_get_sdk_version(), __DATE__, __TIME__);
X	HF_Debug(3, "sdk version(%s),the app_main start time is %s %s\n", hfsys_get_sdk_version(), "Jul 14 2016", "18:58:48");
N
N	if (hfgpio_fmap_check(module_type) != 0) {
N		while (1) {
N			HF_Debug(DEBUG_ERROR, "gpio map file error\n");
X			HF_Debug((10-2), "gpio map file error\n");
N			msleep(1000);
X			hf_thread_delay(1000);
N		}
N		//return 0;
N	}
N	
N	show_reset_reason();
N
N	g_AllSta.byte = 0;
N	if (hfsys_register_system_event((hfsys_event_callback_t) hfsys_event_callback) != HF_SUCCESS) {
X	if (hfsys_register_system_event((hfsys_event_callback_t) hfsys_event_callback) != 0) {
N		u_printf("register system event fail\n");
X		HF_Debug(10,"register system event fail\n");
N	}
N
N	while (!hfnet_wifi_is_active()) {
N		msleep(50);
X		hf_thread_delay(50);
N		//XlinkUartSend("msleep.\r\n", sizeof("msleep.\r\n"));
N	}
N	//XlinkUartSend("hfnet_wifi_is_active.\r\n", sizeof("hfnet_wifi_is_active.\r\n"));
N#if 1
N	int up_result=0;
N	up_result = hfupdate_auto_upgrade(0);
N	if(up_result<0)
N	{
N		u_printf("no entry the auto upgrade mode\n");
X		HF_Debug(10,"no entry the auto upgrade mode\n");
N	}
N	else if(up_result==0)
N	{
N		u_printf("upgrade success\n");
X		HF_Debug(10,"upgrade success\n");
N	}
N	else
N	{
N		u_printf("upgrade fail %d\n",up_result);
X		HF_Debug(10,"upgrade fail %d\n",up_result);
N	}
N#endif
N	
N	if (hfnet_start_assis(ASSIS_PORT) != HF_SUCCESS) {
X	if (hfnet_start_assis(48899) != 0) {
N		HF_Debug(DEBUG_WARN, "start httpd fail\n");
X		HF_Debug((10-2), "start httpd fail\n");
N	}
N
N	if (hfnet_start_httpd(HFTHREAD_PRIORITIES_MID) != HF_SUCCESS) {
X	if (hfnet_start_httpd((2)) != 0) {
N		HF_Debug(DEBUG_WARN, "start httpd fail\n");
X		HF_Debug((10-2), "start httpd fail\n");
N	}
N	
N	if(hfnet_start_uart(HFTHREAD_PRIORITIES_LOW,(hfnet_callback_t)uart_recv_callback)!=HF_SUCCESS)
X	if(hfnet_start_uart((1),(hfnet_callback_t)uart_recv_callback)!=0)
N	{
N		HF_Debug(DEBUG_WARN,"start uart fail!\n");
X		HF_Debug((10-2),"start uart fail!\n");
N	}
N
N//    XlinkUartSend("system init V1.\r\n", 14);
N	hfthread_create(work_phtread, "xlink_loop", 1024, NULL, HFTHREAD_PRIORITIES_NORMAL, NULL, NULL );
X	hfthread_create(work_phtread, "xlink_loop", 1024, 0, (3), 0, 0 );
N	hfthread_create(work_phtread_tcp_client, "xlink_loop_tcp", 128, NULL, HFTHREAD_PRIORITIES_NORMAL, NULL, NULL );
X	hfthread_create(work_phtread_tcp_client, "xlink_loop_tcp", 128, 0, (3), 0, 0 );
N#ifndef __LPT200__
N	hfthread_create(airkiss_domain_lop, "airkiss_domain_lop", 512, NULL, HFTHREAD_PRIORITIES_NORMAL, NULL, NULL );
X	hfthread_create(airkiss_domain_lop, "airkiss_domain_lop", 512, 0, (3), 0, 0 );
N#endif
N	return 1;
N}
N
